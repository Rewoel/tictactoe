<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Tic Tac Toe</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        /* CSS für die Rang-Animation */
        @keyframes rank-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); color: #a7f3d0; /* Tailwind green-200 */ }
            100% { transform: scale(1); }
        }
        .animate-rank-pop {
            animation: rank-pop 0.5s ease-out;
        }

        /* CSS für die Gewinn-Ring-Animation */
        @keyframes win-ring-expand {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
                border-width: 8px; /* Start thick */
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
                border-width: 0px; /* End thin/invisible */
            }
        }
        .win-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            border: 8px solid rgba(255, 255, 0, 0.8); /* Gelb oder helle Farbe für Effekt */
            animation: win-ring-expand 1s ease-out forwards; /* 1 Sekunde Dauer, bleibt am Endzustand */
            z-index: 15; /* Höher als Gewinnlinie und Partikel */
            pointer-events: none; /* Blockiert keine Klicks */
        }
        
        /* CSS für das Rangfortschritts-Overlay */
        @keyframes rank-overlay-enter {
          0% { transform: scale(0.5); opacity: 0; }
          70% { transform: scale(1.05); opacity: 1; }
          100% { transform: scale(1); opacity: 1; }
        }
        .animate-rank-overlay-enter {
          animation: rank-overlay-enter 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }

        @keyframes overlay-fade-in {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        .animate-overlay-fade-in {
          animation: overlay-fade-in 0.3s ease-out forwards;
        }

        /* NEU: Blur-Effekt für Hintergrund bei Modal */
        .backdrop-blur-lg-custom {
            backdrop-filter: blur(8px); /* Adjust blur strength as needed */
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center bg-gray-800 p-4 font-mono relative">
    <!-- Sprachauswahl-Button -->
    <button id="language-toggle" class="absolute top-4 right-4 p-2 bg-gray-600 hover:bg-gray-500 text-white rounded-full shadow-md transition-colors duration-200 z-30 flex items-center gap-1" title="Sprache wechseln">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10" />
            <path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20" />
            <path d="M2 12h20" />
        </svg>
        <span id="current-language-display" class="font-bold">DE</span>
    </button>

    <!-- Profil-Anzeige (oben links) -->
    <div id="profile-display" class="absolute top-4 left-4 p-3 bg-gray-700 rounded-lg shadow-md border border-gray-600 text-white z-30 hidden cursor-pointer">
        <div class="text-lg font-bold" id="username-in-profile">Gast</div>
        <div class="text-sm text-gray-300" id="rank-name-in-profile">Bronze</div>
        <div class="w-full bg-gray-600 rounded-full h-2 mt-1">
            <div id="rank-progress-bar-fill" class="bg-yellow-400 h-2 rounded-full transition-all duration-300 ease-out" style="width: 0%;"></div>
        </div>
        <div class="text-xs text-gray-400 text-right mt-1" id="rank-points-in-profile">0/100 Pkt.</div>
        <!-- Freunde-Code im Profil (jetzt nur noch Name, Rang, Fortschritt) -->
        <!-- <div class="text-xs text-gray-400 mt-2" id="profile-friend-code-display">Code: LÄDT...</div> -->
    </div>

    <!-- NEU: Profil-Übersichts-Modal -->
    <div id="profile-overview-modal" class="fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-50 backdrop-blur-lg-custom hidden">
        <div class="bg-gray-700 p-8 rounded-lg shadow-2xl border-4 border-yellow-400 max-w-sm w-full text-center relative">
            <!-- X-Button entfernt -->
            <h2 class="text-3xl font-extrabold text-white mb-6">Dein Profil</h2>
            
            <div class="mb-4">
                <p class="text-gray-300 text-lg">Name:</p>
                <p id="modal-username" class="text-yellow-300 text-2xl font-bold">LÄDT...</p>
            </div>

            <div class="mb-4">
                <p class="text-gray-300 text-lg">Rang:</p>
                <p id="modal-rank-name" class="text-green-400 text-xl font-semibold">LÄDT...</p>
                <div class="w-full bg-gray-600 rounded-full h-3 mt-2">
                    <div id="modal-rank-progress-bar-fill" class="bg-yellow-400 h-3 rounded-full transition-all duration-300 ease-out" style="width: 0%;"></div>
                </div>
                <p id="modal-rank-points" class="text-gray-400 text-sm mt-1">LÄDT...</p>
            </div>

            <div class="mb-6">
                <p class="text-gray-300 text-lg">Freunde-Code:</p>
                <p id="modal-friend-code" class="text-purple-300 text-xl font-bold break-all cursor-pointer hover:underline">
                    Klicken zum Anzeigen & Kopieren
                </p>
                <span id="copy-status-message" class="text-xs text-green-400 mt-1 hidden"></span>
            </div>
        </div>
    </div>


    <!-- Anmelde-/Registrierungsbildschirm -->
    <div id="auth-screen" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="auth-title">Anmelden / Registrieren</h1>
        <input type="email" id="email-input" placeholder="E-Mail" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500" autocomplete="email">
        <input type="password" id="password-input" placeholder="Passwort" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500" autocomplete="current-password">
        <button id="login-btn" class="w-full max-w-xs p-4 mb-3 bg-blue-500 hover:bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
            Anmelden
        </button>
        <button id="signup-btn" class="w-full max-w-xs p-4 mb-6 bg-green-500 hover:bg-green-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-green-700 active:border-b-0 active:translate-y-1">
            Registrieren
        </button>
        <div class="text-white mb-6" id="auth-or-text">- ODER -</div>
        <button id="google-sign-in-btn" class="w-full max-w-xs p-4 bg-red-500 hover:bg-red-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-red-700 active:border-b-0 active:translate-y-1 flex items-center justify-center gap-2">
            <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path d="M12.0003 4.75C14.0003 4.75 15.5803 5.43 16.7303 6.54L19.2603 4.01C17.5803 2.33 15.0003 1.5 12.0003 1.5C8.30029 1.5 5.01029 3.51 3.32029 6.52L6.34029 8.87C7.14029 6.55 9.38029 4.75 12.0003 4.75V4.75ZM20.5303 12.00C20.5303 11.23 20.4603 10.45 20.3203 9.69H12.0003V14.31H16.9203C16.7203 15.39 16.0303 16.29 15.0603 16.93L17.9703 19.26C19.6403 17.58 20.5303 15.00 20.5303 12.00V12.00ZM6.34029 15.13L3.32029 17.48C5.01029 20.49 8.30029 22.5 12.0003 22.5C15.0003 22.5 17.5803 21.67 19.2603 19.99L16.7303 17.46C15.5803 18.57 14.0003 19.25 12.0003 19.25C9.38029 19.25 7.14029 17.45 6.34029 15.13Z" fill="#FFF"></path>
            </svg>
            Mit Google anmelden
        </button>
        <p id="auth-message" class="text-center text-red-300 mt-4 text-sm hidden"></p>
    </div>

    <!-- Benutzernamensauswahl-Bildschirm -->
    <div id="username-screen" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="username-title">Wähle deinen Namen</h1>
        <p class="text-center text-white mb-6" id="username-prompt">Bevor du spielst, gib bitte einen Namen ein:</p>
        <input type="text" id="username-input" placeholder="Dein Name" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
        <button id="save-username-btn" class="w-full max-w-xs p-4 bg-blue-500 hover:bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
            Namen speichern
        </button>
        <p id="username-message" class="text-center text-red-300 mt-4 text-sm hidden"></p>
    </div>

    <!-- Hauptmenü -->
    <div id="main-menu" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="game-title">Tic Tac Toe</h1>
        <button id="player-vs-player-btn" class="w-full max-w-xs p-4 mb-4 bg-green-500 hover:bg-green-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-green-700 active:border-b-0 active:translate-y-1">
            Spieler vs. Spieler
        </button>
        <button id="player-vs-bot-btn" class="w-full max-w-xs p-4 mb-4 bg-blue-500 hover:bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
            Spieler vs. Bot
        </button>
        <button id="player-vs-friend-btn" class="w-full max-w-xs p-4 mb-4 bg-purple-500 hover:bg-purple-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-purple-700 active:border-b-0 active:translate-y-1">
            Spieler vs. Freund
        </button>
        <button id="logout-btn" class="w-full max-w-xs p-4 bg-gray-600 hover:bg-gray-500 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-gray-800 active:border-b-0 active:translate-y-1">
            Abmelden
        </button>
    </div>

    <!-- Multiplayer Lobby Bildschirm (jetzt "Social Hub") -->
    <div id="multiplayer-lobby-screen" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="multiplayer-lobby-title">Multiplayer Lobby</h1>
        
        <!-- Bereich: Freund hinzufügen -->
        <div class="w-full max-w-xs mb-6 p-4 bg-gray-600 rounded-lg shadow-inner">
            <h2 class="text-xl font-bold text-white mb-3">Freund hinzufügen</h2>
            <input type="text" id="friend-code-to-add-input" placeholder="Freunde-Code eingeben" class="w-full p-3 mb-2 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
            <button id="add-friend-btn" class="w-full p-3 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-lg shadow-md transition-colors duration-200">
                Freund hinzufügen
            </button>
            <p id="add-friend-message" class="text-center text-red-300 mt-2 text-sm hidden"></p>
        </div>

        <!-- Bereich: Deine Freunde (Liste) -->
        <div class="w-full max-w-xs mb-6 p-4 bg-gray-600 rounded-lg shadow-inner">
            <h2 class="text-xl font-bold text-white mb-3">Deine Freunde</h2>
            <div id="friends-list-container" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar">
                <!-- Freund-Items werden hier durch JS eingefügt -->
                <p class="text-gray-400" id="no-friends-message">Noch keine Freunde hinzugefügt.</p>
            </div>
            <p id="friends-list-message" class="text-center text-red-300 mt-2 text-sm hidden"></p>
        </div>

        <!-- Bereich: Spiel beitreten -->
        <input type="text" id="friend-code-input" placeholder="Spiel-Code eingeben" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-purple-500">
        <button id="join-friend-game-btn" class="w-full max-w-xs p-4 mb-4 bg-purple-500 hover:bg-purple-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-purple-700 active:border-b-0 active:translate-y-1">
            Spiel beitreten
        </button>
        <!-- Der "Neues Multiplayer-Spiel starten"-Button wurde hier entfernt -->
        <p id="multiplayer-lobby-message" class="text-center text-red-300 mt-4 text-sm hidden"></p>
        <button id="back-from-lobby-btn" class="px-6 py-3 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-gray-800 active:border-b-0 active:translate-y-1">
            Zurück zum Menü
        </button>
    </div>


    <!-- Spielbereich -->
    <div id="game-area" class="flex-col items-center p-6 bg-gray-700 rounded-lg shadow-xl border-4 border-gray-900 hidden">
        <div id="status-display" class="text-center mb-4">
            <div id="current-player-text" class="text-2xl font-bold text-white">Aktueller Spieler: X</div>
            <div id="rank-info" class="text-xl font-bold text-white mt-2">
                Dein Rang: Bronze (0 Punkte)
                <p class="text-sm text-gray-300 mt-1" id="user-id-display"></p>
                <p class="text-sm text-gray-300 mt-1" id="username-display"></p>
            </div>
        </div>
        <div id="game-board-container" class="my-6 relative grid grid-cols-3 gap-2 p-4 bg-gray-500 border-4 border-gray-800 rounded-lg shadow-xl">
            <!-- Spielfelder werden hier durch JavaScript eingefügt -->
            <canvas id="particles-canvas" class="absolute inset-0 z-5"></canvas>
            <div id="winning-line-overlay" style="position: absolute; z-index: 10; transition: opacity 0.5s ease-out; opacity: 0;"></div>
            <div id="win-ring-overlay" class="hidden"></div> <!-- Win ring container -->
        </div>
        <div class="flex flex-col sm:flex-row gap-4 w-full justify-center">
            <button id="new-game-btn" class="px-6 py-3 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-red-700 active:border-b-0 active:translate-y-1">
                Neues Spiel
            </button>
            <button id="back-to-menu-btn" class="px-6 py-3 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-gray-800 active:border-b-0 active:translate-y-1">
                Zurück zum Menü
            </button>
        </div>
        <div id="bot-thinking-text" class="mt-4 text-white text-lg animate-pulse hidden">Bot denkt nach...</div>
    </div>

    <!-- Rangfortschritts-Overlay -->
    <div id="rank-progress-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-75 z-40 hidden">
        <div id="rank-progress-content" class="flex flex-col items-center p-8 bg-gray-800 rounded-lg shadow-2xl border-4 border-yellow-400">
            <h2 class="text-4xl sm:text-5xl font-extrabold text-white mb-4 text-center" id="rank-overlay-title">Dein Rang</h2>
            <div class="text-xl sm:text-2xl text-gray-300 mb-2">
                <span id="prev-rank-text">Vorheriger Rang: </span><span id="prev-rank-name" class="font-bold text-yellow-200"></span>
            </div>
            <div class="text-6xl sm:text-7xl font-extrabold text-yellow-300 animate-pulse my-4" id="animated-points">
                0
            </div>
            <div class="text-xl sm:text-2xl text-gray-300 mt-2">
                <span id="new-rank-text">Neuer Rang: </span><span id="new-rank-name" class="font-bold text-yellow-200"></span>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs & Game Logic Script -->
    <script type="module">
        // Firebase Konfiguration (von dir bereitgestellt)
        const firebaseConfig = {
            apiKey: "AIzaSyChEMvK_piOrCo9cYtt_mMDTjXd2R4_rU8",
            authDomain: "tictactoe-df871.firebaseapp.com",
            projectId: "tictactoe-df871",
            storageBucket: "tictactoe-df871.firebasestorage.app",
            messagingSenderId: "775114552044",
            appId: "1:775114552044:web:1c7198437e8b275ef66bc9",
            measurementId: "G-5030B21QRX"
        };

        // Firebase SDK Imports (aktualisiert auf Version 12.1.0)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, getDoc, onSnapshot, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

        // Globale Firebase-Variablen
        window.firebaseApp = null;
        window.firebaseAuth = null;
        window.firebaseDb = null;
        window.currentUserId = null;
        window.isFirebaseReady = false;
        window.userRankPoints = 0; // Initialisiere globale Rangpunkte
        window.userRankName = 'Bronze'; // Initialisiere globalen Rangnamen
        window.userDisplayName = null; // Um den gewählten Benutzernamen zu speichern
        window.userFriendCode = null; // Der eindeutige Freundes-Code des Benutzers
        let currentScreen = 'auth'; // 'auth', 'username', 'mainMenu', 'multiplayerLobby', 'game'

        // Multiplayer-spezifische Variablen
        let currentMultiplayerGameRef = null; // Firestore Doc Ref für das aktuelle MP-Spiel
        let gameSessionUnsubscribe = null; // Funktion zum Beenden des onSnapshot Listeners
        let isPlayerX = false; // Ist der aktuelle Spieler Spieler X in einem MP-Spiel?
        let friendsListUnsubscribe = null; // Listener für Freundesliste
        let presenceUpdateInterval = null; // Intervall für Online-Status-Updates


        // Hilfsfunktion, um die Firebase Konfiguration zu laden.
        const getFirebaseConfig = () => {
            return firebaseConfig; // Direkt die bereitgestellte Konfiguration zurückgeben
        };

        // Hilfsfunktion, um die App-ID zu bekommen.
        // Für statische Bereitstellungen verwenden wir projectId als App ID für den Firestore-Pfad
        const getAppId = () => {
            return firebaseConfig.projectId;
        };

        // Translations (globally accessible)
        window.translations = {
            de: {
                gameTitle: "Tic Tac Toe",
                playerVsPlayer: "Spieler vs. Spieler",
                playerVsBot: "Spieler vs. Bot",
                playerVsFriend: "Spieler vs. Freund", // Neu
                newGame: "Neues Spiel",
                backToMenu: "Zurück zum Menü",
                currentPlayer: "Aktueller Spieler",
                winner: "Gewinner",
                draw: "Unentschieden!",
                botThinking: "Bot denkt nach...",
                yourRank: "Dein Rang",
                points: "Punkte",
                loadingRank: "Rang wird geladen...",
                rankBronze: "Bronze",
                rankSilver: "Silber",
                rankGold: "Gold",
                rankPlatinum: "Platin",
                rankDiamond: "Diamant",
                previousRank: "Vorheriger Rang",
                newRank: "Neuer Rang",
                authTitle: "Anmelden / Registrieren",
                emailPlaceholder: "E-Mail",
                passwordPlaceholder: "Passwort",
                loginBtn: "Anmelden",
                signupBtn: "Registrieren",
                or: "- ODER -",
                googleSignIn: "Mit Google anmelden",
                authError: "Fehler bei der Authentifizierung: ",
                usernameTitle: "Wähle deinen Namen",
                usernamePrompt: "Bevor du spielst, gib bitte einen Namen ein:",
                usernamePlaceholder: "Dein Name",
                saveUsernameBtn: "Namen speichern",
                usernameError: "Fehler: ",
                logoutBtn: "Abmelden",
                loggedInAs: "Angemeldet als:",
                multiplayerLobbyTitle: "Multiplayer Lobby", // Neu
                friendCodeInputPlaceholder: "Freunde-Code eingeben", // Neu
                joinGameBtn: "Spiel beitreten", // Neu
                orCreateGameText: "- ODER -", // Neu
                lobbyMessageWaiting: "Warte auf Spieler O...", // Neu
                lobbyMessageJoined: "Spiel beigetreten. Warte auf Start...", // Neu
                lobbyMessageError: "Fehler in der Lobby: ", // Neu
                gameAlreadyStarted: "Das Spiel hat bereits begonnen oder ist voll.", // Neu
                gameNotFound: "Spiel nicht gefunden oder Code ungültig.", // Neu
                gameJoinedSuccess: "Spiel erfolgreich beigetreten!", // Neu
                gameCreatedSuccess: "Multiplayer-Spiel erstellt! Teile deinen Code.", // Neu
                addFriendBtn: "Freund hinzufügen", // Neu
                noFriendsMessage: "Noch keine Freunde hinzugefügt.", // Neu
                friendOnline: "Online", // Neu
                friendOffline: "Offline", // Neu
                inviteBtn: "Einladen", // Neu
                addFriendSuccess: "Freund erfolgreich hinzugefügt!", // Neu
                addFriendError: "Fehler beim Hinzufügen des Freundes: ", // Neu
                friendAlreadyAdded: "Dieser Freund ist bereits in deiner Liste.", // Neu
                selfAddError: "Du kannst dich nicht selbst hinzufügen.", // Neu
                friendCodeNotFound: "Freunde-Code nicht gefunden.", // Neu
                inviteSent: "Einladung gesendet!", // Neu
                inviteFailed: "Einladung konnte nicht gesendet werden.", // Neu
                clickToShowCode: "Klicken zum Anzeigen & Kopieren", // NEU
                codeCopied: "Kopiert!", // NEU
            },
            en: {
                gameTitle: "Tic Tac Toe",
                playerVsPlayer: "Player vs. Player",
                playerVsBot: "Player vs. Bot",
                playerVsFriend: "Player vs. Friend", // New
                newGame: "New Game",
                backToMenu: "Back to Menu",
                currentPlayer: "Current Player",
                winner: "Winner",
                draw: "It's a Draw!",
                botThinking: "Bot is thinking...",
                yourRank: "Your Rank",
                points: "Points",
                loadingRank: "Loading rank...",
                rankBronze: "Bronze",
                rankSilver: "Silver",
                rankGold: "Gold",
                rankPlatinum: "Platinum",
                rankDiamond: "Diamond",
                previousRank: "Previous Rank",
                newRank: "New Rank",
                authTitle: "Sign In / Sign Up",
                emailPlaceholder: "Email",
                passwordPlaceholder: "Password",
                loginBtn: "Sign In",
                signupBtn: "Sign Up",
                or: "- OR -",
                googleSignIn: "Sign in with Google",
                authError: "Authentication error: ",
                usernameTitle: "Choose Your Name",
                usernamePrompt: "Before you play, please enter a name:",
                usernamePlaceholder: "Your Name",
                saveUsernameBtn: "Save Name",
                usernameError: "Error: ",
                logoutBtn: "Log Out",
                loggedInAs: "Logged in as:",
                multiplayerLobbyTitle: "Multiplayer Lobby", // New
                friendCodeInputPlaceholder: "Enter Friend Code", // New
                joinGameBtn: "Join Game", // New
                orCreateGameText: "- OR -", // New
                lobbyMessageWaiting: "Waiting for Player O...", // New
                lobbyMessageJoined: "Game joined. Waiting for start...", // New
                lobbyMessageError: "Lobby Error: ", // New
                gameAlreadyStarted: "Game has already started or or is full.", // New
                gameNotFound: "Game not found or invalid code.", // New
                gameJoinedSuccess: "Game joined successfully!", // New
                gameCreatedSuccess: "Multiplayer game created! Share your code.", // New
                addFriendBtn: "Add Friend", // New
                noFriendsMessage: "No friends added yet.", // New
                friendOnline: "Online", // New
                friendOffline: "Offline", // New
                inviteBtn: "Invite", // New
                addFriendSuccess: "Friend added successfully!", // New
                addFriendError: "Error adding friend: ", // New
                friendAlreadyAdded: "This friend is already in your list.", // New
                selfAddError: "You cannot add yourself.", // New
                friendCodeNotFound: "Friend code not found.", // New
                inviteSent: "Invitation sent!", // New
                inviteFailed: "Failed to send invitation.", // New
                clickToShowCode: "Click to show & copy code", // NEU
                codeCopied: "Copied!", // NEU
            },
        };

        // Game State Variables
        let board = Array(9).fill(null);
        let currentPlayer = 'X';
        let winner = null;
        let winningLine = null;
        let isBotTurn = false;
        let gameMode = 'mainMenu'; // 'mainMenu', 'playerVsPlayer', 'playerVsBot', 'playerVsFriend'
        
        let language = 'de'; // Default language

        // Particle animation variables
        let particles = [];
        let animationFrameId = null;
        let canvas = null;
        let ctx = null;

        // Dom Elements (declared here, assigned in DOMContentLoaded)
        let mainMenuDiv, gameAreaDiv, boardContainerDiv, playerVsPlayerBtn, playerVsBotBtn, playerVsFriendBtn,
            newGameBtn, backToMenuBtn, currentPlayerText, botThinkingText,
            languageToggleBtn, currentLanguageDisplay, gameTitleDisplay,
            rankInfoDisplay, userIdDisplay, winningLineOverlay, winRingOverlay,
            rankProgressOverlay, rankOverlayTitle, prevRankText, newRankText, animatedPointsDisplay,
            authScreenDiv, emailInput, passwordInput, loginBtn, signupBtn, googleSignInBtn, authMessageDisplay, authOrText,
            usernameScreenDiv, usernameInput, saveUsernameBtn, usernameMessageDisplay,
            authTitleDisplay, usernameTitleDisplay, usernamePromptDisplay, logoutBtn,
            profileDisplay, usernameInProfile, rankNameInProfile, rankProgressBarFill, rankPointsInProfile, // profileFriendCodeDisplay entfernt
            multiplayerLobbyScreen, multiplayerLobbyTitle, yourCodeText, yourFriendCodeDisplay, friendCodeInput, joinFriendGameBtn, orCreateGameText, multiplayerLobbyMessage, backFromLobbyBtn, // createMultiplayerGameBtn entfernt
            friendCodeToAddInput, addFriendBtn, addFriendMessage, friendsListContainer, noFriendsMessage, friendsListMessage, // NEU Freundschaftssystem
            profileOverviewModal, modalUsername, modalRankName, modalRankProgressBarFill, modalRankPoints, modalFriendCode, copyStatusMessage; // NEU Profil-Modal Elemente

        // Zustand für Freundescode-Anzeige im Modal
        let isFriendCodeRevealed = false; 

        // --- Utility Functions ---
        // Get current translation object
        const t = () => window.translations[language];

        // Function to get rank name (globalized to be accessible for Firebase part)
        window.getRankName = (points) => {
            const currentTranslations = t(); // Use the current translation object
            if (points >= 400) return currentTranslations.rankDiamond;
            if (points >= 300) return currentTranslations.rankPlatinum;
            if (points >= 200) return currentTranslations.rankGold;
            if (points >= 100) return currentTranslations.rankSilver;
            return currentTranslations.rankBronze;
        };

        // Funktion zur Berechnung des Rangfortschritts (Punkte innerhalb des aktuellen Rangs)
        const getRankProgressDetails = (points) => {
            let basePoints = 0;
            let nextRankPoints = 100;
            if (points >= 400) { // Diamond
                basePoints = 400;
                nextRankPoints = 400; // No next rank beyond Diamond for now
            } else if (points >= 300) { // Platinum
                basePoints = 300;
                nextRankPoints = 400;
            } else if (points >= 200) { // Gold
                basePoints = 200;
                nextRankPoints = 300;
            } else if (points >= 100) { // Silver
                basePoints = 100;
                nextRankPoints = 200;
            }
            const pointsInCurrentRank = points - basePoints;
            const pointsToNextRank = nextRankPoints - basePoints;
            const progressPercentage = pointsToNextRank > 0 ? (pointsInCurrentRank / pointsToNextRank) * 100 : 100;

            return {
                pointsInCurrentRank,
                pointsToNextRank,
                progressPercentage: Math.min(100, progressPercentage) // Clamp to 100%
            };
        };

        // --- UI Update Functions (defined early to be accessible) ---
        const updateTextContent = () => {
            // Main Menu
            if (gameTitleDisplay) gameTitleDisplay.textContent = t().gameTitle;
            if (playerVsPlayerBtn) playerVsPlayerBtn.textContent = t().playerVsPlayer;
            if (playerVsBotBtn) playerVsBotBtn.textContent = t().playerVsBot;
            if (playerVsFriendBtn) playerVsFriendBtn.textContent = t().playerVsFriend;
            if (newGameBtn) newGameBtn.textContent = t().newGame;
            if (backToMenuBtn) backToMenuBtn.textContent = t().backToMenu;
            if (logoutBtn) logoutBtn.textContent = t().logoutBtn;

            // Game Area / Status
            if (botThinkingText) botThinkingText.textContent = t().botThinking;
            
            // Language Toggle
            if (languageToggleBtn) languageToggleBtn.title = language === 'de' ? 'Sprache wechseln' : 'Change language';
            if (currentLanguageDisplay) currentLanguageDisplay.textContent = language.toUpperCase();

            // Rank Overlay
            if (rankOverlayTitle) rankOverlayTitle.textContent = t().yourRank;
            if (prevRankText) prevRankText.textContent = t().previousRank + ": ";
            if (newRankText) newRankText.textContent = t().newRank + ": ";

            // Auth Screen
            if (authTitleDisplay) authTitleDisplay.textContent = t().authTitle;
            if (emailInput) emailInput.placeholder = t().emailPlaceholder;
            if (passwordInput) passwordInput.placeholder = t().passwordPlaceholder; 
            if (loginBtn) loginBtn.textContent = t().loginBtn;
            if (signupBtn) signupBtn.textContent = t().signupBtn;
            if (authOrText) authOrText.textContent = t().or;
            if (googleSignInBtn) googleSignInBtn.innerHTML = `<svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12.0003 4.75C14.0003 4.75 15.5803 5.43 16.7303 6.54L19.2603 4.01C17.5803 2.33 15.0003 1.5 12.0003 1.5C8.30029 1.5 5.01029 3.51 3.32029 6.52L6.34029 8.87C7.14029 6.55 9.38029 4.75 12.0003 4.75V4.75ZM20.5303 12.00C20.5303 11.23 20.4603 10.45 20.3203 9.69H12.0003V14.31H16.9203C16.7203 15.39 16.0303 16.29 15.0603 16.93L17.9703 19.26C19.6403 17.58 20.5303 15.00 20.5303 12.00V12.00ZM6.34029 15.13L3.32029 17.48C5.01029 20.49 8.30029 22.5 12.0003 22.5C15.0003 22.5 17.5803 21.67 19.2603 19.99L16.7303 17.46C15.5803 18.57 14.0003 19.25 12.0003 19.25C9.38029 19.25 7.14029 17.45 6.34029 15.13Z" fill="#FFF"></path></svg> ${t().googleSignIn}`;
            
            // Username Screen
            if (usernameTitleDisplay) usernameTitleDisplay.textContent = t().usernameTitle;
            if (usernamePromptDisplay) usernamePromptDisplay.textContent = t().usernamePrompt;
            if (usernameInput) usernameInput.placeholder = t().usernamePlaceholder;
            if (saveUsernameBtn) saveUsernameBtn.textContent = t().saveUsernameBtn;

            // Multiplayer Lobby Screen
            if (multiplayerLobbyTitle) multiplayerLobbyTitle.textContent = t().multiplayerLobbyTitle;
            if (yourCodeText) yourCodeText.textContent = t().yourCodeText;
            if (yourFriendCodeDisplay) yourFriendCodeDisplay.textContent = window.userFriendCode || 'LÄDT...';
            if (friendCodeInput) friendCodeInput.placeholder = t().friendCodeInputPlaceholder; // Jetzt "Spiel-Code eingeben"
            if (joinFriendGameBtn) joinFriendGameBtn.textContent = t().joinGameBtn;
            if (orCreateGameText) orCreateGameText.textContent = t().orCreateGameText;
            if (backFromLobbyBtn) backFromLobbyBtn.textContent = t().backToMenu;
            if (friendCodeToAddInput) friendCodeToAddInput.placeholder = t().friendCodeInputPlaceholder;
            if (addFriendBtn) addFriendBtn.textContent = t().addFriendBtn;
            if (noFriendsMessage) noFriendsMessage.textContent = t().noFriendsMessage;
            
            // NEU: Profil-Modal Freunde-Code-Anzeige
            if (modalFriendCode && !isFriendCodeRevealed) {
                modalFriendCode.textContent = t().clickToShowCode;
            } else if (modalFriendCode && isFriendCodeRevealed) {
                modalFriendCode.textContent = window.userFriendCode || 'N/A';
            }
        };

        const updateStatusDisplay = () => {
            let statusText = '';
            if (winner) {
                if (winner === 'Unentschieden') {
                    statusText = t().draw;
                    if (currentPlayerText) currentPlayerText.className = "text-3xl font-bold text-yellow-300";
                } else {
                    statusText = `${t().winner}: ${winner}!`;
                    if (currentPlayerText) currentPlayerText.className = "text-3xl font-bold text-green-400";
                }
            } else {
                statusText = `${t().currentPlayer}: ${currentPlayer}`;
                if (currentPlayerText) currentPlayerText.className = "text-2xl font-bold text-white";
            }
            if (currentPlayerText) currentPlayerText.textContent = statusText;

            // Update main rank info display (in game area)
            if (window.isFirebaseReady && rankInfoDisplay && userIdDisplay) {
                rankInfoDisplay.innerHTML = `${t().yourRank}: ${window.userRankName} (${window.userRankPoints} ${t().points})`;
                userIdDisplay.textContent = `User ID: ${window.currentUserId || 'N/A'}`;
                const usernameDisplayElement = document.getElementById('username-display');
                if (usernameDisplayElement) {
                    usernameDisplayElement.textContent = `${t().loggedInAs} ${window.userDisplayName || 'Gast'}`;
                }
                rankInfoDisplay.style.display = 'block';
                userIdDisplay.style.display = 'block';
                if (usernameDisplayElement) usernameDisplayElement.style.display = 'block';

            } else if (rankInfoDisplay) {
                rankInfoDisplay.textContent = t().loadingRank;
                if (userIdDisplay) userIdDisplay.textContent = '';
                const usernameDisplayElement = document.getElementById('username-display');
                if(usernameDisplayElement) usernameDisplayElement.textContent = '';
                rankInfoDisplay.style.display = 'block';
            }

            // Update profile display (top-left corner)
            // Freunde-Code im oberen linken Profilfeld wird jetzt nicht mehr angezeigt.
            if (profileDisplay && window.isFirebaseReady) {
                if (usernameInProfile) usernameInProfile.textContent = window.userDisplayName || 'Gast';
                if (rankNameInProfile) rankNameInProfile.textContent = window.userRankName;
                if (rankPointsInProfile) {
                    const progress = getRankProgressDetails(window.userRankPoints);
                    if (progress.pointsToNextRank === 0) { // Max rank reached
                        rankPointsInProfile.textContent = `${window.userRankPoints} ${t().points}`;
                    } else {
                        rankPointsInProfile.textContent = `${progress.pointsInCurrentRank}/${progress.pointsToNextRank} ${t().points}`;
                    }
                }
                if (rankProgressBarFill) {
                    const progress = getRankProgressDetails(window.userRankPoints);
                    rankProgressBarFill.style.width = `${progress.progressPercentage}%`;
                }
                profileDisplay.classList.remove('hidden'); // Ensure profile display is shown if ready
            } else if (profileDisplay) {
                profileDisplay.classList.add('hidden'); // Hide if not ready
            }

            // NEU: Update des Profil-Modals, falls sichtbar
            if (profileOverviewModal && !profileOverviewModal.classList.contains('hidden')) {
                updateProfileModalContent();
            }
        };

        // NEU: Funktion zum Aktualisieren des Inhalts des Profil-Modals
        const updateProfileModalContent = () => {
            if (modalUsername) modalUsername.textContent = window.userDisplayName || 'Gast';
            if (modalRankName) modalRankName.textContent = window.userRankName;
            if (modalRankPoints) {
                const progress = getRankProgressDetails(window.userRankPoints);
                if (progress.pointsToNextRank === 0) {
                    modalRankPoints.textContent = `${window.userRankPoints} ${t().points}`;
                } else {
                    modalRankPoints.textContent = `${progress.pointsInCurrentRank}/${progress.pointsToNextRank} ${t().points}`;
                }
            }
            if (modalRankProgressBarFill) {
                const progress = getRankProgressDetails(window.userRankPoints);
                modalRankProgressBarFill.style.width = `${progress.progressPercentage}%`;
            }

            // NEU: Logik für Freundescode-Anzeige im Modal
            if (modalFriendCode) {
                if (isFriendCodeRevealed) {
                    modalFriendCode.textContent = window.userFriendCode || 'N/A';
                } else {
                    modalFriendCode.textContent = t().clickToShowCode;
                }
            }
        };


        const showAuthMessage = (message, isError = true) => {
            if (authMessageDisplay) {
                authMessageDisplay.textContent = (isError ? t().authError : '') + message;
                authMessageDisplay.classList.remove('hidden');
                authMessageDisplay.classList.toggle('text-red-300', isError);
                authMessageDisplay.classList.toggle('text-green-300', !isError);
            }
        };

        const hideAuthMessage = () => {
            if (authMessageDisplay) {
                authMessageDisplay.classList.add('hidden');
            }
        };

        const showUsernameMessage = (message, isError = true) => {
            if (usernameMessageDisplay) {
                usernameMessageDisplay.textContent = (isError ? t().usernameError : '') + message;
                usernameMessageDisplay.classList.remove('hidden');
                usernameMessageDisplay.classList.toggle('text-red-300', isError);
                usernameMessageDisplay.classList.toggle('text-green-300', !isError);
            }
        };

        const hideUsernameMessage = () => {
            if (usernameMessageDisplay) {
                usernameMessageDisplay.classList.add('hidden');
            }
        };

        const showMultiplayerLobbyMessage = (message, isError = true) => {
            if (multiplayerLobbyMessage) {
                multiplayerLobbyMessage.textContent = (isError ? t().lobbyMessageError : '') + message;
                multiplayerLobbyMessage.classList.remove('hidden');
                multiplayerLobbyMessage.classList.toggle('text-red-300', isError);
                multiplayerLobbyMessage.classList.toggle('text-green-300', !isError);
            }
        };

        const hideMultiplayerLobbyMessage = () => {
            if (multiplayerLobbyMessage) {
                multiplayerLobbyMessage.classList.add('hidden');
            }
        };

        // NEU: Nachrichten für Freunde hinzufügen Bereich
        const showAddFriendMessage = (message, isError = true) => {
            if (addFriendMessage) {
                addFriendMessage.textContent = (isError ? t().addFriendError : '') + message;
                addFriendMessage.classList.remove('hidden');
                addFriendMessage.classList.toggle('text-red-300', isError);
                addFriendMessage.classList.toggle('text-green-300', !isError);
            }
        };

        const hideAddFriendMessage = () => {
            if (addFriendMessage) {
                addFriendMessage.classList.add('hidden');
            }
        };

        // NEU: Nachrichten für Freunde Liste Bereich
        const showFriendsListMessage = (message, isError = true) => {
            if (friendsListMessage) {
                friendsListMessage.textContent = (isError ? t().addFriendError : '') + message; // Reusing error text for now
                friendsListMessage.classList.remove('hidden');
                friendsListMessage.classList.toggle('text-red-300', isError);
                friendsListMessage.classList.toggle('text-green-300', !isError);
            }
        };

        const hideFriendsListMessage = () => {
            if (friendsListMessage) {
                friendsListMessage.classList.add('hidden');
            }
        };


        const renderScreen = (screenName) => {
            mainMenuDiv.classList.add('hidden');
            gameAreaDiv.classList.add('hidden');
            authScreenDiv.classList.add('hidden');
            usernameScreenDiv.classList.add('hidden');
            multiplayerLobbyScreen.classList.add('hidden'); // New screen
            profileOverviewModal.classList.add('hidden'); // NEU: Profil-Modal immer verstecken
            if (profileDisplay) profileDisplay.classList.add('hidden'); // Hide profile by default

            // NEU: Abmeldung von Firebase-Listen bei Bildschirmwechsel
            if (gameSessionUnsubscribe) {
                gameSessionUnsubscribe();
                gameSessionUnsubscribe = null;
            }
            if (friendsListUnsubscribe) {
                friendsListUnsubscribe();
                friendsListUnsubscribe = null;
            }
            if (presenceUpdateInterval) {
                clearInterval(presenceUpdateInterval);
                presenceUpdateInterval = null;
            }
            isFriendCodeRevealed = false; // Zurücksetzen des Zustands beim Schließen des Modals/Wechseln des Bildschirms

            switch (screenName) {
                case 'auth':
                    authScreenDiv.classList.remove('hidden');
                    break;
                case 'username':
                    usernameScreenDiv.classList.remove('hidden');
                    break;
                case 'mainMenu':
                    mainMenuDiv.classList.remove('hidden');
                    if (window.isFirebaseReady && window.userDisplayName) profileDisplay.classList.remove('hidden');
                    break;
                case 'multiplayerLobby': // New case for social hub
                    multiplayerLobbyScreen.classList.remove('hidden');
                    if (window.isFirebaseReady && window.userDisplayName) profileDisplay.classList.remove('hidden');
                    if (window.isFirebaseReady && window.currentUserId) {
                        // Starte Listen für Freundesliste und präsenter Status
                        subscribeToFriendsList();
                        startPresenceUpdate();
                    }
                    break;
                case 'game':
                    gameAreaDiv.classList.remove('hidden');
                    if (window.isFirebaseReady && window.userDisplayName) profileDisplay.classList.remove('hidden');
                    break;
            }
            currentScreen = screenName;
            updateTextContent(); // Ensure texts are correct for the new screen
        };
        
        // --- Firebase-related Functions ---
        window.initializeFirebase = async () => {
            try {
                const fConfig = getFirebaseConfig();
                window.firebaseApp = initializeApp(fConfig);
                window.firebaseAuth = getAuth(window.firebaseApp);
                window.firebaseDb = getFirestore(window.firebaseApp);

                onAuthStateChanged(window.firebaseAuth, async (user) => {
                    if (user) {
                        window.currentUserId = user.uid;
                        window.isFirebaseReady = true;
                        console.log("Firebase: User authenticated:", user.uid);
                        // Check for user's display name and friend code
                        await checkUserDisplayName(user.uid);
                        window.subscribeToRankChanges(); // Subscribe only after user and name are checked
                    } else {
                        window.currentUserId = null;
                        window.isFirebaseReady = false;
                        window.userDisplayName = null; // Clear display name on logout
                        window.userFriendCode = null; // Clear friend code on logout
                        console.log("Firebase: User signed out or not authenticated.");
                        renderScreen('auth'); // Go to auth screen if not authenticated
                    }
                    updateStatusDisplay(); // Update UI
                });
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                window.isFirebaseReady = false;
                showAuthMessage("Firebase-Initialisierungsfehler: " + error.message);
            }
        };

        const generateFriendCode = async () => {
            // Generiere einen einfachen Freundes-Code basierend auf der UID
            if (window.currentUserId) {
                return window.currentUserId.substring(0, 6).toUpperCase();
            }
            return null;
        };

        const checkUserDisplayName = async (uid) => {
            if (!window.firebaseDb) return;
            const profileDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${uid}/profile`, 'userProfile');
            try {
                const docSnap = await getDoc(profileDocRef);
                if (docSnap.exists() && docSnap.data().displayName) {
                    window.userDisplayName = docSnap.data().displayName;
                    window.userFriendCode = docSnap.data().friendCode || await generateFriendCode();
                    if (!docSnap.data().friendCode) { // Wenn Code gerade generiert wurde, speichere ihn
                        await setDoc(profileDocRef, { friendCode: window.userFriendCode }, { merge: true });
                        // NEU: Freunde-Code in globaler Map speichern, wenn er neu ist
                        await setDoc(doc(window.firebaseDb, `artifacts/${getAppId()}/public/friendCodeMap`, window.userFriendCode), { uid: window.currentUserId }, { merge: true });
                    }
                    console.log("User Display Name:", window.userDisplayName, "Friend Code:", window.userFriendCode);
                    renderScreen('mainMenu'); // Gehe zum Hauptmenü, wenn Name existiert
                } else {
                    window.userDisplayName = null;
                    window.userFriendCode = null;
                    renderScreen('username'); // Gehe zum Benutzernamen-Bildschirm, wenn kein Name vorhanden ist
                }
            } catch (error) {
                console.error("Error fetching user profile:", error);
                showUsernameMessage("Fehler beim Laden des Profils: " + error.message);
                renderScreen('username'); // Fallback zum Benutzernamen-Bildschirm bei Fehler
            }
        };

        // NEU: Periodisches Update des Online-Status
        const updateLastActive = async () => {
            if (!window.firebaseDb || !window.currentUserId) return;
            const profileDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/profile`, 'userProfile');
            try {
                await updateDoc(profileDocRef, { lastActive: Date.now() });
                console.log("Presence updated:", Date.now());
            } catch (error) {
                console.error("Error updating presence:", error);
            }
        };

        const startPresenceUpdate = () => {
            if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);
            updateLastActive(); // Update immediately
            presenceUpdateInterval = setInterval(updateLastActive, 30000); // Every 30 seconds
        };


        window.subscribeToRankChanges = () => {
            if (!window.isFirebaseReady || !window.currentUserId || !window.firebaseDb) {
                console.warn("Cannot subscribe to rank changes: Firebase not ready or user ID missing.");
                return;
            }

            const rankDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/rank`, 'playerRank');

            window.rankUnsubscribe = onSnapshot(rankDocRef, (docSnap) => {
                let newPoints = 0;
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    newPoints = data.points;
                } else {
                    // Rang initialisieren, wenn er nicht existiert
                    const initialPoints = 0;
                    setDoc(rankDocRef, { points: initialPoints }).catch(error => console.error("Error setting initial rank:", error));
                    newPoints = initialPoints;
                }

                const oldPoints = window.userRankPoints; // Use the current global value
                const oldRankName = window.getRankName(oldPoints);
                const newRankName = window.getRankName(newPoints);

                if (newPoints !== oldPoints || newRankName !== oldRankName) {
                    // Trigger the rank progress display
                    window.showRankProgressOverlay(oldPoints, newPoints, oldRankName, newRankName);
                    
                    // Trigger the subtle pop animation on the rank text in the status bar
                    if (document.getElementById('rank-info')) {
                      document.getElementById('rank-info').classList.add('animate-rank-pop');
                      setTimeout(() => {
                          document.getElementById('rank-info').classList.remove('animate-rank-pop');
                      }, 500);
                    }
                }
                
                window.userRankPoints = newPoints;
                window.userRankName = newRankName;
                updateStatusDisplay(); // Update status bar with new rank info
            }, (error) => {
                console.error("Error listening to rank:", error);
            });
        };

        window.updatePlayerRank = async (gameOutcome) => {
            if (!window.firebaseDb || !window.currentUserId || gameMode !== 'playerVsBot') {
                console.log("Not in bot mode or Firestore/User ID not ready. Rank will not be updated.");
                return;
            }

            const rankDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/rank`, 'playerRank');
            let newPoints = window.userRankPoints;

            switch (gameOutcome) {
                case 'win':
                    newPoints += 20;
                    break;
                case 'loss':
                    newPoints = Math.max(0, newPoints - 10);
                    break;
                case 'draw':
                    newPoints += 5;
                    break;
                default:
                    break;
            }

            try {
                await updateDoc(rankDocRef, { points: newPoints });
            } catch (error) {
                console.error("Error updating rank:", error);
            }
        };

        window.showRankProgressOverlay = (oldP, newP, oldR, newR) => {
            const overlay = document.getElementById('rank-progress-overlay');
            const overlayContent = document.getElementById('rank-progress-content');
            
            if (!overlay || !overlayContent || !animatedPointsDisplay || !prevRankText || !newRankText || !rankOverlayTitle) {
                console.error("Rank progress overlay elements not found. Cannot show animation.");
                return;
            }

            // Set initial points for animation
            let animatedPoints = oldP;
            overlayContent.querySelector('#prev-rank-name').textContent = oldR;
            overlayContent.querySelector('#new-rank-name').textContent = newR;
            animatedPointsDisplay.textContent = Math.round(animatedPoints); // Use the global animatedPointsDisplay

            overlay.classList.remove('hidden');
            overlay.classList.add('animate-overlay-fade-in');
            overlayContent.classList.remove('scale-0'); // Ensure it's not scaled down from previous animation
            overlayContent.classList.add('animate-rank-overlay-enter');

            let start = null;
            const duration = 2000; // 2 seconds for animation

            const animatePoints = (currentTime) => {
                if (!start) start = currentTime;
                const progress = (currentTime - start) / duration;

                if (progress < 1) {
                    const easedProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
                    const current = oldP + (newP - oldP) * easedProgress;
                    animatedPointsDisplay.textContent = Math.round(current);
                    requestAnimationFrame(animatePoints);
                } else {
                    animatedPointsDisplay.textContent = newP;
                    // Hide after a total of 4 seconds
                    setTimeout(() => {
                        overlay.classList.add('hidden');
                        overlay.classList.remove('animate-overlay-fade-in');
                        overlayContent.classList.remove('animate-rank-overlay-enter');
                    }, 2000); // 2 seconds after point animation finishes
                }
            };
            requestAnimationFrame(animatePoints);
        };

        // --- Game Logic Functions ---
        const calculateWinner = (squares) => {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6],
            ];
            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
                    return { winner: squares[a], line: lines[i] };
                }
            }
            return { winner: null, line: null };
        };

        const handleSquareClick = async (i) => {
            if (winner || board[i] || (gameMode === 'playerVsBot' && isBotTurn)) {
                return;
            }

            if (gameMode === 'playerVsFriend') {
                if (!currentMultiplayerGameRef || !window.currentUserId) {
                    showMultiplayerLobbyMessage("Fehler: Kein Multiplayer-Spiel aktiv.", true);
                    return;
                }
                // Only allow moves if it's your turn
                if ((isPlayerX && currentPlayer === 'X') || (!isPlayerX && currentPlayer === 'O')) {
                    const newBoard = [...board];
                    newBoard[i] = currentPlayer;

                    const { winner: potentialWinner, line: winningLineFound } = calculateWinner(newBoard);
                    let newGameStatus = 'playing';
                    let gameOutcome = null;

                    if (potentialWinner) {
                        newGameStatus = 'finished';
                        gameOutcome = potentialWinner;
                    } else if (newBoard.every(square => square !== null)) {
                        newGameStatus = 'finished';
                        gameOutcome = 'Unentschieden';
                    }

                    await updateGameSession({
                        board: newBoard,
                        currentPlayer: currentPlayer === 'X' ? 'O' : 'X',
                        winner: gameOutcome,
                        winningLine: winningLineFound,
                        status: newGameStatus
                    });
                } else {
                    // It's not your turn
                    showMultiplayerLobbyMessage("Warte auf den Zug des anderen Spielers.", false);
                }
                return; // Exit as logic is handled by Firestore listener
            }

            // --- Local Game Logic (Player vs Player / Player vs Bot) ---
            board[i] = currentPlayer;
            
            const { winner: potentialWinner, line: winningLineFound } = calculateWinner(board);
            if (potentialWinner) {
                winner = potentialWinner;
                winningLine = winningLineFound;
                if (winner !== 'Unentschieden') {
                    triggerWinRingAnimation();
                }
                if (gameMode === 'playerVsBot') {
                    if (winner === currentPlayer) { // CurrentPlayer is the human who just made the move
                        window.updatePlayerRank('win');
                    } else {
                        window.updatePlayerRank('loss');
                    }
                }
                renderBoard(); // Render final state immediately after win/draw
                updateStatusDisplay();
            } else if (board.every(square => square !== null)) {
                winner = 'Unentschieden';
                winningLine = null;
                if (gameMode === 'playerVsBot') {
                    window.updatePlayerRank('draw');
                }
                renderBoard(); // Render final state immediately after win/draw
                updateStatusDisplay();
            } else {
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                renderBoard(); // Render board after player's valid move, before bot's turn
                updateStatusDisplay();
            }
            
            // Only trigger bot's turn if no winner/draw after player's move
            if (gameMode === 'playerVsBot' && currentPlayer === 'O' && !winner) {
                isBotTurn = true;
                if (botThinkingText) botThinkingText.classList.remove('hidden');
                renderBoard(); // Re-render to disable squares while bot is thinking
                setTimeout(() => {
                    makeBotMove(); // This function now only updates game state
                    isBotTurn = false; // Bot's turn is over
                    if (botThinkingText) botThinkingText.classList.add('hidden');
                    renderBoard(); // Re-render to enable squares if no winner/draw after bot's move
                    updateStatusDisplay(); // Update status display after bot's move
                }, 2000); // Bot thinking delay
            }
        };

        const makeBotMove = () => {
            if (winner) return; // Should not happen if called correctly

            const emptySquares = board.map((val, idx) => val === null ? idx : null).filter(val => val !== null);
            if (emptySquares.length === 0) return;

            let botMoveIndex = -1;

            // 1. Check if bot can win
            for (let i = 0; i < emptySquares.length; i++) {
                const tempBoard = [...board];
                tempBoard[emptySquares[i]] = 'O';
                const { winner: tempWinner } = calculateWinner(tempBoard);
                if (tempWinner === 'O') {
                    botMoveIndex = emptySquares[i];
                    break;
                }
            }

            // 2. Check if player can win and block
            if (botMoveIndex === -1) {
                for (let i = 0; i < emptySquares.length; i++) {
                    const tempBoard = [...board];
                    tempBoard[emptySquares[i]] = 'X';
                    const { winner: tempWinner } = calculateWinner(tempBoard);
                    if (tempWinner === 'X') {
                        botMoveIndex = emptySquares[i];
                        break;
                    }
                }
            }

            // 3. Take center if available
            if (botMoveIndex === -1 && board[4] === null) {
                botMoveIndex = 4;
            }

            // 4. Take a corner if available
            if (botMoveIndex === -1) {
                const corners = [0, 2, 6, 8].filter(idx => board[idx] === null);
                if (corners.length > 0) {
                    botMoveIndex = corners[Math.floor(Math.random() * corners.length)];
                }
            }

            // 5. Take any empty square
            if (botMoveIndex === -1) {
                const randomIndex = Math.floor(Math.random() * emptySquares.length);
                botMoveIndex = emptySquares[randomIndex];
            }

            board[botMoveIndex] = 'O'; // Bot makes its move
            
            const { winner: potentialWinner, line: winningLineFound } = calculateWinner(board);
            if (potentialWinner) {
                winner = potentialWinner;
                winningLine = winningLineFound;
                if (winner !== 'Unentschieden') {
                    triggerWinRingAnimation();
                }
                if (gameMode === 'playerVsBot') {
                    if (winner === 'O') { // Bot ('O') won
                        window.updatePlayerRank('loss'); // Human player ('X') lost
                    } else {
                        // This case (X winning after O's move) should ideally not happen if bot logic is sound,
                        // but if it does, it's a win for the player from the game's perspective.
                        window.updatePlayerRank('win');
                    }
                }
            } else if (board.every(square => square !== null)) {
                winner = 'Unentschieden';
                winningLine = null;
                if (gameMode === 'playerVsBot') {
                    window.updatePlayerRank('draw');
                }
            } else {
                currentPlayer = 'X'; // After bot's move, it's always player 'X's turn
            }

            // IMPORTANT: renderBoard() and updateStatusDisplay() are now called in the setTimeout callback
            // in handleSquareClick, AFTER isBotTurn is set to false.
        };

        // Resets local game state, not the Firestore document
        const resetGameLocalState = () => {
            board = Array(9).fill(null);
            currentPlayer = 'X';
            winner = null;
            winningLine = null;
            isBotTurn = false;
            if (botThinkingText) botThinkingText.classList.add('hidden');
            if (winRingOverlay) winRingOverlay.classList.add('hidden');
        };

        const resetGame = () => {
            resetGameLocalState(); // Reset local state
            if (gameSessionUnsubscribe) { // Unsubscribe from multiplayer game if active
                gameSessionUnsubscribe();
                gameSessionUnsubscribe = null;
            }
            currentMultiplayerGameRef = null;
            isPlayerX = false;
            renderBoard();
            updateStatusDisplay();
        };

        const backToMainMenu = () => {
            resetGame(); // Reset any active game (local or multiplayer)
            renderScreen('mainMenu');
        };

        // --- Animation Functions ---
        const drawWinningLine = () => {
            if (!winningLine || !boardContainerDiv || !winningLineOverlay) {
                if (winningLineOverlay) winningLineOverlay.style.opacity = '0';
                return;
            }

            const lineThickness = 8; // in Pixeln
            const boardPaddingPx = 16; // 1rem = 16px (for p-4)

            const boardRect = boardContainerDiv.getBoundingClientRect();
            const effectiveGridWidth = boardRect.width - (2 * boardPaddingPx);
            const effectiveGridHeight = boardRect.height - (2 * boardPaddingPx);

            const cellWidth = effectiveGridWidth / 3;
            const cellHeight = effectiveGridHeight / 3;

            const getSquareCenter = (squareIndex) => {
                const row = Math.floor(squareIndex / 3);
                const col = squareIndex % 3;
                const centerX = boardPaddingPx + col * cellWidth + cellWidth / 2;
                const centerY = boardPaddingPx + row * cellHeight + cellHeight / 2;
                return { x: centerX, y: centerY };
            };

            const startCellIndex = winningLine[0];
            const endCellIndex = winningLine[2]; 

            const startCenter = getSquareCenter(startCellIndex);
            const endCenter = getSquareCenter(endCellIndex);

            const dx = endCenter.x - startCenter.x;
            const dy = endCenter.y - startCenter.y;

            const lineLength = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            const midX = (startCenter.x + endCenter.x) / 2;
            const midY = (startCenter.y + endCenter.y) / 2;

            winningLineOverlay.style.cssText = `
                background-color: rgb(34, 197, 94);
                border-radius: 9999px;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                position: absolute;
                z-index: 10;
                transition: opacity 0.5s ease-out;
                opacity: 1; /* Make visible for animation */
                width: ${lineLength}px;
                height: ${lineThickness}px;
                left: ${midX - lineLength / 2}px;
                top: ${midY - lineThickness / 2}px;
                transform-origin: center center;
                transform: rotate(${angle}deg);
            `;

            // Particle animation
            startParticleAnimation();
        };

        let particlesAnimationFrameId = null;
        let particleArray = [];

        const startParticleAnimation = () => {
            if (particlesAnimationFrameId) cancelAnimationFrame(particlesAnimationFrameId); // Stop existing animation

            if (!canvas || !ctx || !boardContainerDiv || !winningLine) {
                console.warn("Cannot start particle animation: Missing required elements or winningLine.");
                return;
            }

            const boardRect = boardContainerDiv.getBoundingClientRect();
            canvas.width = boardRect.width;
            canvas.height = boardRect.height;

            particleArray = []; // Clear previous particles
            const boardPaddingPx = 16;
            const effectiveGridWidth = boardRect.width - (2 * boardPaddingPx);
            const effectiveGridHeight = boardRect.height - (2 * boardPaddingPx);
            const cellWidth = effectiveGridWidth / 3;
            const cellHeight = effectiveGridHeight / 3;

            winningLine.forEach(squareIndex => {
                const row = Math.floor(squareIndex / 3);
                const col = squareIndex % 3;
                const centerX = boardPaddingPx + col * cellWidth + cellWidth / 2;
                const centerY = boardPaddingPx + row * cellHeight + cellHeight / 2;

                for (let i = 0; i < 15; i++) {
                    particleArray.push({ // Using particleArray here, consistent with declaration
                        x: centerX,
                        y: centerY,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 0,
                        maxLife: 60 + Math.random() * 30,
                        radius: 2 + Math.random() * 2,
                        color: '0, 255, 0'
                    });
                }
            });

            const animateParticles = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < particleArray.length; i++) { // Using particleArray here
                    const p = particleArray[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life++;

                    const alpha = 1 - (p.life / p.maxLife);
                    const currentRadius = p.radius * Math.max(0.01, alpha);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, currentRadius, 0, Math.PI * 2, false);
                    ctx.fillStyle = `rgba(${p.color}, ${alpha})`;
                    ctx.fill();

                    if (p.life >= p.maxLife) {
                        particleArray.splice(i, 1);
                        i--;
                    }
                }
                if (particleArray.length > 0) { // Check 'particleArray' length
                    animationFrameId = requestAnimationFrame(animateParticles);
                } else {
                    animationFrameId = null; // Animation finished
                }
            };
            animationFrameId = requestAnimationFrame(animateParticles); // Use general animationFrameId
        };

        let winRingAnimationTimeout = null;
        const triggerWinRingAnimation = () => {
            if (!winRingOverlay) {
                console.warn("winRingOverlay element not found. Cannot trigger win ring animation.");
                return;
            }
            // Clear any existing animation before starting a new one
            if (winRingAnimationTimeout) clearTimeout(winRingAnimationTimeout);
            
            winRingOverlay.classList.remove('hidden');
            // Remove and re-add the class to re-trigger the animation
            winRingOverlay.classList.remove('win-ring');
            void winRingOverlay.offsetWidth; // Trigger reflow to restart animation
            winRingOverlay.classList.add('win-ring');

            winRingAnimationTimeout = setTimeout(() => {
                winRingOverlay.classList.add('hidden');
            }, 1000); // Duration of the animation
        };


        const renderBoard = () => {
            if (!boardContainerDiv || !canvas || !winningLineOverlay || !winRingOverlay) {
                console.error("Board rendering elements not found."); // Keep this error for critical missing elements
                return;
            }
            boardContainerDiv.innerHTML = ''; // Clear existing board
            // Re-add canvas and winning line overlay as they might be cleared
            boardContainerDiv.appendChild(canvas);
            boardContainerDiv.appendChild(winningLineOverlay);
            boardContainerDiv.appendChild(winRingOverlay); // Ensure win ring overlay is present

            for (let i = 0; i < 9; i++) {
                const squareBtn = document.createElement('button');
                squareBtn.classList.add(
                    'w-24', 'h-24', 'sm:w-28', 'sm:h-28', 'md:w-32', 'md:h-32',
                    'bg-gray-200', 'border-4', 'border-gray-700', 'rounded-md',
                    'flex', 'items-center', 'justify-center', 'text-4xl', 'sm:text-5xl', 'md:text-6xl',
                    'font-bold', 'font-mono', 'text-gray-800', 'shadow-inner',
                    'hover:bg-gray-300', 'transition-colors', 'duration-200',
                    'relative', 'z-20' // Higher z-index to be clickable over canvas
                );
                squareBtn.dataset.index = i; // Store index for click handler
                squareBtn.textContent = board[i];

                // Disable logic based on current game state and game mode
                let disableButton = false;
                if (winner || board[i] !== null) {
                    disableButton = true;
                } else if (gameMode === 'playerVsBot' && isBotTurn) {
                    disableButton = true;
                } else if (gameMode === 'playerVsFriend') {
                    // In multiplayer, disable if it's not our turn
                    if ((isPlayerX && currentPlayer === 'O') || (!isPlayerX && currentPlayer === 'X')) {
                        disableButton = true;
                    }
                }

                if (disableButton) {
                    squareBtn.disabled = true;
                    squareBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    squareBtn.disabled = false;
                    squareBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                
                squareBtn.addEventListener('click', () => handleSquareClick(i));
                boardContainerDiv.appendChild(squareBtn);
            }

            if (winningLine) {
                drawWinningLine();
            } else {
                winningLineOverlay.style.opacity = '0';
            }
        };


        // Initial render logic
        document.addEventListener('DOMContentLoaded', () => {
            // Assign ALL DOM elements once the document is ready, at the very beginning
            mainMenuDiv = document.getElementById('main-menu');
            gameAreaDiv = document.getElementById('game-area');
            boardContainerDiv = document.getElementById('game-board-container');
            playerVsPlayerBtn = document.getElementById('player-vs-player-btn');
            playerVsBotBtn = document.getElementById('player-vs-bot-btn');
            playerVsFriendBtn = document.getElementById('player-vs-friend-btn'); // New
            newGameBtn = document.getElementById('new-game-btn');
            backToMenuBtn = document.getElementById('back-to-menu-btn');
            currentPlayerText = document.getElementById('current-player-text');
            botThinkingText = document.getElementById('bot-thinking-text');
            languageToggleBtn = document.getElementById('language-toggle');
            currentLanguageDisplay = document.getElementById('current-language-display');
            gameTitleDisplay = document.getElementById('game-title');
            rankInfoDisplay = document.getElementById('rank-info');
            userIdDisplay = document.getElementById('user-id-display');
            winningLineOverlay = document.getElementById('winning-line-overlay');
            winRingOverlay = document.getElementById('win-ring-overlay');
            rankProgressOverlay = document.getElementById('rank-progress-overlay');
            rankOverlayTitle = document.getElementById('rank-overlay-title');
            prevRankText = document.getElementById('prev-rank-text');
            newRankText = document.getElementById('new-rank-name'); 
            animatedPointsDisplay = document.getElementById('animated-points');

            // New Auth/Username elements
            authScreenDiv = document.getElementById('auth-screen');
            emailInput = document.getElementById('email-input');
            passwordInput = document.getElementById('password-input');
            loginBtn = document.getElementById('login-btn');
            signupBtn = document.getElementById('signup-btn');
            googleSignInBtn = document.getElementById('google-sign-in-btn');
            authMessageDisplay = document.getElementById('auth-message');
            authOrText = document.getElementById('auth-or-text'); // New
            usernameScreenDiv = document.getElementById('username-screen');
            usernameInput = document.getElementById('username-input');
            saveUsernameBtn = document.getElementById('save-username-btn');
            usernameMessageDisplay = document.getElementById('username-message');
            authTitleDisplay = document.getElementById('auth-title');
            usernameTitleDisplay = document.getElementById('username-title');
            usernamePromptDisplay = document.querySelector('#username-screen p'); // Select the p tag in username screen
            logoutBtn = document.getElementById('logout-btn');

            // Profile Display elements
            profileDisplay = document.getElementById('profile-display');
            usernameInProfile = document.getElementById('username-in-profile');
            rankNameInProfile = document.getElementById('rank-name-in-profile');
            rankProgressBarFill = document.getElementById('rank-progress-bar-fill');
            rankPointsInProfile = document.getElementById('rank-points-in-profile');
            // profileFriendCodeDisplay = document.getElementById('profile-friend-code-display'); // Removed from direct assignment as it's not used directly anymore

            // Multiplayer Lobby elements
            multiplayerLobbyScreen = document.getElementById('multiplayer-lobby-screen');
            multiplayerLobbyTitle = document.getElementById('multiplayer-lobby-title');
            yourCodeText = document.getElementById('your-code-text');
            yourFriendCodeDisplay = document.getElementById('your-friend-code');
            friendCodeInput = document.getElementById('friend-code-input');
            joinFriendGameBtn = document.getElementById('join-friend-game-btn');
            orCreateGameText = document.getElementById('or-create-game-text');
            // createMultiplayerGameBtn = document.getElementById('create-multiplayer-game-btn'); // ENTFERNT
            multiplayerLobbyMessage = document.getElementById('multiplayer-lobby-message');
            backFromLobbyBtn = document.getElementById('back-from-lobby-btn');
            friendCodeToAddInput = document.getElementById('friend-code-to-add-input'); // NEU
            addFriendBtn = document.getElementById('add-friend-btn'); // NEU
            addFriendMessage = document.getElementById('add-friend-message'); // NEU
            friendsListContainer = document.getElementById('friends-list-container'); // NEU
            noFriendsMessage = document.getElementById('no-friends-message'); // NEU
            friendsListMessage = document.getElementById('friends-list-message'); // NEU

            // NEU: Profil-Modal Elemente
            profileOverviewModal = document.getElementById('profile-overview-modal');
            // closeProfileModalBtn = document.getElementById('close-profile-modal-btn'); // Removed this button
            modalUsername = document.getElementById('modal-username');
            modalRankName = document.getElementById('modal-rank-name');
            modalRankProgressBarFill = document.getElementById('modal-rank-progress-bar-fill');
            modalRankPoints = document.getElementById('modal-rank-points');
            modalFriendCode = document.getElementById('modal-friend-code');
            copyStatusMessage = document.getElementById('copy-status-message');


            canvas = document.getElementById('particles-canvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
            }
            
            // --- Event Handlers (defined inside DOMContentLoaded to ensure scope) ---
            const handleEmailLogin = async () => {
                hideAuthMessage();
                const email = emailInput.value;
                const password = passwordInput.value;
                if (!email || !password) {
                    showAuthMessage("Bitte E-Mail und Passwort eingeben.");
                    return;
                }
                try {
                    await signInWithEmailAndPassword(window.firebaseAuth, email, password);
                    // onAuthStateChanged will handle screen transition
                } catch (error) {
                    showAuthMessage(error.message);
                }
            };

            const handleEmailSignup = async () => {
                hideAuthMessage();
                const email = emailInput.value;
                const password = passwordInput.value;
                if (!email || !password) {
                    showAuthMessage("Bitte E-Mail und Passwort eingeben.");
                    return;
                }
                try {
                    await createUserWithEmailAndPassword(window.firebaseAuth, email, password);
                    // onAuthStateChanged will handle screen transition
                } catch (error) {
                    showAuthMessage(error.message);
                }
            };

            const handleGoogleSignIn = async () => {
                hideAuthMessage();
                const provider = new GoogleAuthProvider();
                try {
                    await signInWithPopup(window.firebaseAuth, provider);
                    // onAuthStateChanged will handle screen transition
                } catch (error) {
                    showAuthMessage(error.message);
                }
            };

            const handleSaveUsername = async () => {
                hideUsernameMessage();
                const displayName = usernameInput.value.trim();
                if (!displayName) {
                    showUsernameMessage("Bitte einen gültigen Namen eingeben.");
                    return;
                }
                if (!window.currentUserId || !window.firebaseDb) {
                    showUsernameMessage("Benutzer nicht angemeldet oder Firebase nicht bereit.");
                    return;
                }

                const friendCode = await generateFriendCode();
                if (!friendCode) {
                    showUsernameMessage("Fehler beim Generieren des Freundes-Codes.");
                    return;
                }

                const profileDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/profile`, 'userProfile');
                try {
                    await setDoc(profileDocRef, { displayName: displayName, friendCode: friendCode, lastActive: Date.now() }, { merge: true });
                    // NEU: Freundes-Code in globaler Map speichern
                    await setDoc(doc(window.firebaseDb, `artifacts/${getAppId()}/public/friendCodeMap`, friendCode), { uid: window.currentUserId }, { merge: true });

                    window.userDisplayName = displayName;
                    window.userFriendCode = friendCode;
                    renderScreen('mainMenu'); // Go to main menu after saving name
                } catch (error) {
                    showUsernameMessage("Fehler beim Speichern des Namens: " + error.message);
                }
            };

            const handleLogout = async () => {
                try {
                    await signOut(window.firebaseAuth);
                    // onAuthStateChanged will automatically redirect to auth screen
                    window.userRankPoints = 0; // Reset rank on logout
                    window.userRankName = 'Bronze';
                    window.userFriendCode = null; // Clear friend code on logout
                    updateStatusDisplay();
                } catch (error) {
                    console.error("Error signing out:", error);
                }
            };

            // NEU: Funktion zum Hinzufügen eines Freundes
            const addFriendByCode = async () => {
                hideAddFriendMessage();
                const codeToAdd = friendCodeToAddInput.value.trim().toUpperCase();

                if (!codeToAdd) {
                    showAddFriendMessage("Bitte einen Freundes-Code eingeben.", true);
                    return;
                }
                if (codeToAdd === window.userFriendCode) {
                    showAddFriendMessage(t().selfAddError, true);
                    return;
                }

                if (!window.currentUserId || !window.firebaseDb) {
                    showAddFriendMessage("Benutzer nicht angemeldet oder Firebase nicht bereit.", true);
                    return;
                }

                try {
                    // 1. Finde die UID des Freundes über die globale Map
                    const friendCodeMapDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/public/friendCodeMap`, codeToAdd);
                    const friendCodeMapSnap = await getDoc(friendCodeMapDocRef);

                    if (!friendCodeMapSnap.exists()) {
                        showAddFriendMessage(t().friendCodeNotFound, true);
                        return;
                    }
                    const friendUid = friendCodeMapSnap.data().uid;

                    // 2. Überprüfe, ob der Freund bereits hinzugefügt wurde
                    const currentUserFriendDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/friends`, friendUid);
                    const currentUserFriendSnap = await getDoc(currentUserFriendDocRef);
                    if (currentUserFriendSnap.exists()) {
                        showAddFriendMessage(t().friendAlreadyAdded, true);
                        return;
                    }

                    // 3. Hole den Anzeigenamen des Freundes
                    const friendProfileDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${friendUid}/profile`, 'userProfile');
                    const friendProfileSnap = await getDoc(friendProfileDocRef);
                    if (!friendProfileSnap.exists() || !friendProfileSnap.data().displayName) {
                        showAddFriendMessage("Freundesprofil nicht gefunden oder unvollständig.", true);
                        return;
                    }
                    const friendDisplayName = friendProfileSnap.data().displayName;

                    // 4. Füge den Freund zur Liste des aktuellen Benutzers hinzu
                    await setDoc(currentUserFriendDocRef, {
                        displayName: friendDisplayName,
                        friendCode: codeToAdd,
                        addedAt: Date.now()
                    });

                    // 5. Füge den aktuellen Benutzer zur Liste des Freundes hinzu (gegenseitige Freundschaft)
                    const friendFriendDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${friendUid}/friends`, window.currentUserId);
                    await setDoc(friendFriendDocRef, {
                        displayName: window.userDisplayName,
                        friendCode: window.userFriendCode,
                        addedAt: Date.now()
                    });

                    showAddFriendMessage(t().addFriendSuccess, false);
                    friendCodeToAddInput.value = ''; // Eingabefeld leeren
                } catch (error) {
                    console.error("Error adding friend:", error);
                    showAddFriendMessage(error.message, true);
                }
            };

            // NEU: Funktion zum Rendern der Freundesliste
            const renderFriendsList = async (friendsData) => {
                friendsListContainer.innerHTML = ''; // Vorhandene Liste leeren
                if (friendsData.length === 0) {
                    noFriendsMessage.classList.remove('hidden');
                    return;
                }
                noFriendsMessage.classList.add('hidden');

                const friendPromises = friendsData.map(async (friendDoc) => {
                    const friendUid = friendDoc.id;
                    const friendInfo = friendDoc.data();
                    let isOnline = false;
                    let lastActiveTime = 0;

                    // Hole den aktuellen Online-Status des Freundes
                    if (window.firebaseDb) {
                        const friendProfileRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${friendUid}/profile`, 'userProfile');
                        try {
                            const friendProfileSnap = await getDoc(friendProfileRef);
                            if (friendProfileSnap.exists() && friendProfileSnap.data().lastActive) {
                                lastActiveTime = friendProfileSnap.data().lastActive;
                                // Als online betrachten, wenn in den letzten 60 Sekunden aktiv
                                isOnline = (Date.now() - lastActiveTime) < 60000; 
                            }
                        } catch (error) {
                            console.warn("Could not fetch friend's presence:", friendUid, error);
                        }
                    }

                    const friendItem = document.createElement('div');
                    friendItem.classList.add('flex', 'items-center', 'justify-between', 'p-2', 'bg-gray-700', 'rounded-md', 'shadow-sm');
                    friendItem.innerHTML = `
                        <div class="flex flex-col">
                            <span class="text-white font-bold">${friendInfo.displayName}</span>
                            <span class="text-xs ${isOnline ? 'text-green-400' : 'text-gray-400'}">
                                ${isOnline ? t().friendOnline : t().friendOffline}
                            </span>
                        </div>
                        <button class="invite-friend-btn px-3 py-1 bg-purple-500 hover:bg-purple-600 text-white text-sm font-bold rounded-md transition-colors duration-200" data-friend-uid="${friendUid}" ${!isOnline ? 'disabled' : ''}>
                            ${t().inviteBtn}
                        </button>
                    `;
                    friendsListContainer.appendChild(friendItem);
                });

                await Promise.all(friendPromises); // Warte, bis alle Freunde gerendert sind

                // Füge Event-Listener für Einladungs-Buttons hinzu
                friendsListContainer.querySelectorAll('.invite-friend-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const friendUid = event.target.dataset.friendUid;
                        if (friendUid) {
                            sendGameInvitation(friendUid);
                        }
                    });
                });
            };


            // NEU: Abonnieren der Freundesliste
            const subscribeToFriendsList = () => {
                if (!window.firebaseDb || !window.currentUserId) {
                    console.warn("Cannot subscribe to friends list: Firebase not ready or user ID missing.");
                    return;
                }
                if (friendsListUnsubscribe) friendsListUnsubscribe(); // Cleanup previous subscription

                const friendsCollectionRef = collection(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/friends`);
                friendsListUnsubscribe = onSnapshot(friendsCollectionRef, (snapshot) => {
                    const friendsData = [];
                    snapshot.forEach(doc => {
                        friendsData.push(doc); // doc contains id and data()
                    });
                    renderFriendsList(friendsData);
                }, (error) => {
                    console.error("Error listening to friends list:", error);
                    showFriendsListMessage("Fehler beim Laden der Freundesliste.", true);
                });
            };

            // NEU: Funktion zum Senden einer Spiel-Einladung
            const sendGameInvitation = async (invitedFriendUid) => {
                showFriendsListMessage("Sende Einladung...", false);
                if (!window.currentUserId || !window.userDisplayName || !invitedFriendUid || !window.firebaseDb) {
                    showFriendsListMessage(t().inviteFailed + " (Fehlende Daten)", true);
                    return;
                }

                try {
                    // Erstelle eine eindeutige Spiel-ID für diese Einladung
                    const gameId = `${window.currentUserId}-${invitedFriendUid}-${Date.now()}`;
                    const gameRef = doc(window.firebaseDb, `artifacts/${getAppId()}/public/games`, gameId);

                    const initialGameState = {
                        players: {
                            X: {
                                uid: window.currentUserId,
                                displayName: window.userDisplayName,
                                friendCode: window.userFriendCode
                            },
                            O: { // Zielspieler der Einladung
                                uid: invitedFriendUid,
                                displayName: '', // Wird bei Annahme aktualisiert
                                friendCode: ''
                            }
                        },
                        board: Array(9).fill(null),
                        currentPlayer: 'X',
                        winner: null,
                        winningLine: null,
                        status: 'invited', // Neuer Status: 'invited', 'waiting', 'playing', 'finished'
                        createdAt: Date.now()
                    };

                    await setDoc(gameRef, initialGameState);

                    // Optional: Eine Einladungsnachricht im Profil des eingeladenen Spielers setzen
                    const invitedUserProfileRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${invitedFriendUid}/profile`, 'userProfile');
                    await updateDoc(invitedUserProfileRef, {
                        incomingInvitation: {
                            gameId: gameId,
                            fromUid: window.currentUserId,
                            fromDisplayName: window.userDisplayName,
                            timestamp: Date.now()
                        }
                    }, { merge: true });

                    showFriendsListMessage(t().inviteSent, false);

                    // Starte das Hosting des Spiels für den Einladenden
                    currentMultiplayerGameRef = gameRef;
                    isPlayerX = true;
                    subscribeToGameSession(gameId); // Beginne auf Updates für dieses Spiel zu lauschen
                    renderScreen('game'); // Gehe direkt zum Spielbildschirm als Host
                    resetGameLocalState(); // Setze den lokalen Spielstatus zurück
                    updateStatusDisplay();

                } catch (error) {
                    console.error("Error sending game invitation:", error);
                    showFriendsListMessage(t().inviteFailed + error.message, true);
                }
            };


            // --- Multiplayer Logic (defined inside DOMContentLoaded) ---
            // createMultiplayerGame wurde entfernt und seine Funktionalität (öffentliches Spiel erstellen) ist nicht mehr direkt über einen Button erreichbar.
            // Die Spiele werden nun hauptsächlich über Einladungen gestartet.

            const joinMultiplayerGame = async () => {
                hideMultiplayerLobbyMessage();
                const gameCodeToJoin = friendCodeInput.value.trim(); // Jetzt ist es der Game-Code, nicht unbedingt ein Freundes-Code
                if (!gameCodeToJoin) {
                    showMultiplayerLobbyMessage("Bitte einen Spiel-Code eingeben.", true);
                    return;
                }
                if (!window.userDisplayName) {
                    showMultiplayerLobbyMessage("Dein Name ist nicht verfügbar. Bitte melde dich erneut an.", true);
                    return;
                }

                try {
                    const gameRef = doc(window.firebaseDb, `artifacts/${getAppId()}/public/games`, gameCodeToJoin);
                    const gameDoc = await getDoc(gameRef);

                    if (!gameDoc.exists()) {
                        showMultiplayerLobbyMessage(t().gameNotFound, true);
                        return;
                    }

                    const gameData = gameDoc.data();
                    if (gameData.players.O !== null && gameData.players.O.uid !== window.currentUserId) { // Prüfe, ob Spieler O besetzt ist
                        showMultiplayerLobbyMessage(t().gameAlreadyStarted, true);
                        return;
                    }
                    if (gameData.players.X && gameData.players.X.uid === window.currentUserId) { // Prüfe, ob Spieler X selbst beitreten möchte
                        showMultiplayerLobbyMessage("Du bist bereits Spieler X in diesem Spiel.", true);
                        // Könnte hier zum Spiel wechseln statt Fehlermeldung
                        currentMultiplayerGameRef = gameRef;
                        isPlayerX = true;
                        subscribeToGameSession(gameCodeToJoin);
                        return;
                    }

                    // Update game with Player O's info
                    await updateDoc(gameRef, {
                        'players.O': {
                            uid: window.currentUserId,
                            displayName: window.userDisplayName,
                            friendCode: window.userFriendCode // Dein Freundes-Code
                        },
                        status: 'playing' // Start the game
                    });

                    currentMultiplayerGameRef = gameRef;
                    isPlayerX = false; // Current player is O
                    showMultiplayerLobbyMessage(t().gameJoinedSuccess, false);
                    subscribeToGameSession(gameCodeToJoin);

                } catch (error) {
                    console.error("Error joining multiplayer game:", error);
                    showMultiplayerLobbyMessage("Fehler beim Beitreten des Spiels: " + error.message, true);
                }
            };

            const subscribeToGameSession = (gameId) => {
                if (gameSessionUnsubscribe) { // Unsubscribe from previous game session if any
                    gameSessionUnsubscribe();
                }

                currentMultiplayerGameRef = doc(window.firebaseDb, `artifacts/${getAppId()}/public/games`, gameId);
                gameSessionUnsubscribe = onSnapshot(currentMultiplayerGameRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        board = data.board;
                        currentPlayer = data.currentPlayer;
                        winner = data.winner;
                        winningLine = data.winningLine;
                        gameMode = 'playerVsFriend'; // Ensure game mode is correct
                        
                        // Automatically transition to game screen if not already there and game is playing
                        if (data.status === 'playing' && currentScreen !== 'game') {
                            renderScreen('game');
                            resetGameLocalState(); // Reset only local state, not the Firestore game
                            // Bestimme, ob du Spieler X oder O bist, wenn das Spiel startet
                            if (data.players.X && data.players.X.uid === window.currentUserId) {
                                isPlayerX = true;
                            } else if (data.players.O && data.players.O.uid === window.currentUserId) {
                                isPlayerX = false;
                            }
                        } else if (data.status === 'waiting' && currentScreen !== 'multiplayerLobby') {
                            renderScreen('multiplayerLobby');
                        } else if (data.status === 'invited') {
                            // Wenn dies eine Einladung für diesen Benutzer ist
                            if (data.players.O && data.players.O.uid === window.currentUserId && currentScreen !== 'game') {
                                // Hier könnte man eine Benachrichtigung anzeigen und einen Button zum Akzeptieren
                                showMultiplayerLobbyMessage(`Du wurdest von ${data.players.X.displayName} zu einem Spiel eingeladen! Tritt bei mit Code: ${gameId}`, false);
                                // Setze das Eingabefeld mit dem Code voraus
                                friendCodeInput.value = gameId;
                            } else if (data.players.X && data.players.X.uid === window.currentUserId && currentScreen !== 'game') {
                                // Du bist der Einladende, warte auf den Freund
                                showMultiplayerLobbyMessage(`Einladung an ${data.players.O.displayName || 'deinen Freund'} gesendet. Warte auf Annahme...`, false);
                                renderScreen('multiplayerLobby'); // Bleibe in der Lobby
                            }
                        } else if (data.status === 'finished') {
                            // Game ended, can show a message or transition back
                            console.log("Multiplayer game finished.");
                            showMultiplayerLobbyMessage(`Spiel beendet. Gewinner: ${data.winner || 'Unentschieden'}`, false);
                        }

                        renderBoard();
                        updateStatusDisplay();
                    } else {
                        console.log("Multiplayer game ended or not found (document deleted).");
                        resetGame(); // Reset game state
                        backToMainMenu(); // Go back to main menu
                        showMultiplayerLobbyMessage("Das Multiplayer-Spiel wurde beendet.", true);
                    }
                }, (error) => {
                    console.error("Error listening to game session:", error);
                    showMultiplayerLobbyMessage("Verbindungsproblem mit dem Spiel: " + error.message, true);
                    resetGame();
                    backToMainMenu();
                });
            };

            const updateGameSession = async (updates) => {
                if (currentMultiplayerGameRef) {
                    try {
                        await updateDoc(currentMultiplayerGameRef, updates);
                    } catch (error) {
                        console.error("Error updating game session:", error);
                        showMultiplayerLobbyMessage("Fehler beim Aktualisieren des Spiels: " + error.message, true);
                    }
                }
            };
            // --- Ende der Event-Handler ---

            // --- Event Listeners ---
            if (playerVsPlayerBtn) {
                playerVsPlayerBtn.addEventListener('click', () => {
                    gameMode = 'playerVsPlayer';
                    renderScreen('game'); // Directly go to game screen
                    resetGame();
                });
            }

            if (playerVsBotBtn) {
                playerVsBotBtn.addEventListener('click', () => {
                    gameMode = 'playerVsBot';
                    renderScreen('game'); // Directly go to game screen
                    resetGame();
                });
            }

            if (playerVsFriendBtn) { // New event listener for Player vs Friend
                playerVsFriendBtn.addEventListener('click', () => {
                    gameMode = 'playerVsFriend'; // Set game mode
                    renderScreen('multiplayerLobby'); // Go to multiplayer lobby
                    hideMultiplayerLobbyMessage();
                });
            }

            if (newGameBtn) newGameBtn.addEventListener('click', resetGame);
            if (backToMenuBtn) backToMenuBtn.addEventListener('click', backToMainMenu);
            if (languageToggleBtn) {
                languageToggleBtn.addEventListener('click', () => {
                    language = (language === 'de' ? 'en' : 'de');
                    updateTextContent();
                });
            }

            // Auth Screen Event Listeners
            if (loginBtn) loginBtn.addEventListener('click', handleEmailLogin);
            if (signupBtn) signupBtn.addEventListener('click', handleEmailSignup);
            if (googleSignInBtn) googleSignInBtn.addEventListener('click', handleGoogleSignIn);

            // Username Screen Event Listener
            if (saveUsernameBtn) saveUsernameBtn.addEventListener('click', handleSaveUsername);

            // Logout Button Event Listener
            if (logoutBtn) logoutBtn.addEventListener('click', handleLogout);

            // Multiplayer Lobby Event Listeners
            // createMultiplayerGameBtn.addEventListener wurde entfernt
            if (joinFriendGameBtn) joinFriendGameBtn.addEventListener('click', joinMultiplayerGame);
            if (backFromLobbyBtn) backFromLobbyBtn.addEventListener('click', backToMainMenu);
            
            // NEU: Freundschaftssystem Event Listener
            if (addFriendBtn) addFriendBtn.addEventListener('click', addFriendByCode);

            // NEU: Event Listener für Profil-Anzeige und Modal
            if (profileDisplay) {
                profileDisplay.addEventListener('click', () => {
                    if (window.isFirebaseReady && window.userDisplayName) {
                        isFriendCodeRevealed = false; // Code ist beim Öffnen des Modals immer zuerst versteckt
                        updateProfileModalContent(); // Aktualisiere den Inhalt vor dem Anzeigen
                        profileOverviewModal.classList.remove('hidden');
                    }
                });
            }
            // NEU: Klick außerhalb des Modals zum Schließen
            if (profileOverviewModal) {
                profileOverviewModal.addEventListener('click', (event) => {
                    // Prüfen, ob der Klick direkt auf dem Modal-Hintergrund war und nicht auf dem Inhalt
                    if (event.target === profileOverviewModal) {
                        profileOverviewModal.classList.add('hidden');
                    }
                });
            }

            // NEU: Event Listener für Freundescode im Modal (Anzeigen und Kopieren)
            if (modalFriendCode) {
                modalFriendCode.addEventListener('click', async () => {
                    if (!isFriendCodeRevealed) {
                        isFriendCodeRevealed = true;
                        updateProfileModalContent(); // Zeigt den Code an
                        // Code sofort kopieren
                        try {
                            if (window.userFriendCode) {
                                document.execCommand('copy'); // Fallback for clipboard API restrictions in iframe
                                // Fallback: Create a temporary textarea to copy text if native Clipboard API doesn't work
                                const tempTextArea = document.createElement('textarea');
                                tempTextArea.value = window.userFriendCode;
                                document.body.appendChild(tempTextArea);
                                tempTextArea.select();
                                document.execCommand('copy');
                                document.body.removeChild(tempTextArea);

                                if (copyStatusMessage) {
                                    copyStatusMessage.textContent = t().codeCopied;
                                    copyStatusMessage.classList.remove('hidden');
                                    setTimeout(() => {
                                        copyStatusMessage.classList.add('hidden');
                                    }, 2000); // Nachricht nach 2 Sekunden ausblenden
                                }
                            }
                        } catch (err) {
                            console.error('Kopieren fehlgeschlagen:', err);
                            if (copyStatusMessage) {
                                copyStatusMessage.textContent = "Kopieren fehlgeschlagen!";
                                copyStatusMessage.classList.remove('hidden');
                                copyStatusMessage.classList.add('text-red-400');
                                setTimeout(() => {
                                    copyStatusMessage.classList.add('hidden');
                                    copyStatusMessage.classList.remove('text-red-400');
                                }, 2000);
                            }
                        }
                    }
                });
            }


            // --- Ende der Event Listener ---

            // Call functions that rely on elements *after* they have all been assigned
            updateTextContent(); 
            renderBoard(); // Render board initially (even if hidden) to ensure elements exist
            window.initializeFirebase(); // Initialize Firebase once DOM is ready
        });
    </script>
</body>
</html>
