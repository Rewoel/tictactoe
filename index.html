<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Tic Tac Toe</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        /* CSS für die Rang-Animation */
        @keyframes rank-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); color: #a7f3d0; /* Tailwind green-200 */ }
            100% { transform: scale(1); }
        }
        .animate-rank-pop {
            animation: rank-pop 0.5s ease-out;
        }

        /* CSS für die Gewinn-Ring-Animation */
        @keyframes win-ring-expand {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
                border-width: 8px; /* Start thick */
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
                border-width: 0px; /* End thin/invisible */
            }
        }
        .win-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            border: 8px solid rgba(255, 255, 0, 0.8); /* Gelb oder helle Farbe für Effekt */
            animation: win-ring-expand 1s ease-out forwards; /* 1 Sekunde Dauer, bleibt am Endzustand */
            z-index: 15; /* Höher als Gewinnlinie und Partikel */
            pointer-events: none; /* Blockiert keine Klicks */
        }
        
        /* CSS für das Rangfortschritts-Overlay */
        @keyframes rank-overlay-enter {
          0% { transform: scale(0.5); opacity: 0; }
          70% { transform: scale(1.05); opacity: 1; }
          100% { transform: scale(1); opacity: 1; }
        }
        .animate-rank-overlay-enter {
          animation: rank-overlay-enter 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }

        @keyframes overlay-fade-in {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        .animate-overlay-fade-in {
          animation: overlay-fade-in 0.3s ease-out forwards;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center bg-gray-800 p-4 font-mono relative">
    <!-- Sprachauswahl-Button -->
    <button id="language-toggle" class="absolute top-4 right-4 p-2 bg-gray-600 hover:bg-gray-500 text-white rounded-full shadow-md transition-colors duration-200 z-30 flex items-center gap-1" title="Sprache wechseln">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10" />
            <path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20" />
            <path d="M2 12h20" />
        </svg>
        <span id="current-language-display" class="font-bold">DE</span>
    </button>

    <!-- Profil-Anzeige (oben links) -->
    <div id="profile-display" class="absolute top-4 left-4 p-3 bg-gray-700 rounded-lg shadow-md border border-gray-600 text-white z-30 hidden">
        <div class="text-lg font-bold" id="username-in-profile">Gast</div>
        <div class="text-sm text-gray-300" id="rank-name-in-profile">Bronze</div>
        <div class="w-full bg-gray-600 rounded-full h-2 mt-1">
            <div id="rank-progress-bar-fill" class="bg-yellow-400 h-2 rounded-full transition-all duration-300 ease-out" style="width: 0%;"></div>
        </div>
        <div class="text-xs text-gray-400 text-right mt-1" id="rank-points-in-profile">0/100 Pkt.</div>
    </div>


    <!-- Anmelde-/Registrierungsbildschirm -->
    <div id="auth-screen" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="auth-title">Anmelden / Registrieren</h1>
        <input type="email" id="email-input" placeholder="E-Mail" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500" autocomplete="email">
        <input type="password" id="password-input" placeholder="Passwort" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500" autocomplete="current-password">
        <button id="login-btn" class="w-full max-w-xs p-4 mb-3 bg-blue-500 hover:bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
            Anmelden
        </button>
        <button id="signup-btn" class="w-full max-w-xs p-4 mb-6 bg-green-500 hover:bg-green-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-green-700 active:border-b-0 active:translate-y-1">
            Registrieren
        </button>
        <div class="text-white mb-6" id="auth-or-text">- ODER -</div>
        <button id="google-sign-in-btn" class="w-full max-w-xs p-4 bg-red-500 hover:bg-red-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-red-700 active:border-b-0 active:translate-y-1 flex items-center justify-center gap-2">
            <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path d="M12.0003 4.75C14.0003 4.75 15.5803 5.43 16.7303 6.54L19.2603 4.01C17.5803 2.33 15.0003 1.5 12.0003 1.5C8.30029 1.5 5.01029 3.51 3.32029 6.52L6.34029 8.87C7.14029 6.55 9.38029 4.75 12.0003 4.75V4.75ZM20.5303 12.00C20.5303 11.23 20.4603 10.45 20.3203 9.69H12.0003V14.31H16.9203C16.7203 15.39 16.0303 16.29 15.0603 16.93L17.9703 19.26C19.6403 17.58 20.5303 15.00 20.5303 12.00V12.00ZM6.34029 15.13L3.32029 17.48C5.01029 20.49 8.30029 22.5 12.0003 22.5C15.0003 22.5 17.5803 21.67 19.2603 19.99L16.7303 17.46C15.5803 18.57 14.0003 19.25 12.0003 19.25C9.38029 19.25 7.14029 17.45 6.34029 15.13Z" fill="#FFF"></path>
            </svg>
            Mit Google anmelden
        </button>
        <p id="auth-message" class="text-center text-red-300 mt-4 text-sm hidden"></p>
    </div>

    <!-- Benutzernamensauswahl-Bildschirm -->
    <div id="username-screen" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="username-title">Wähle deinen Namen</h1>
        <p class="text-center text-white mb-6" id="username-prompt">Bevor du spielst, gib bitte einen Namen ein:</p>
        <input type="text" id="username-input" placeholder="Dein Name" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
        <button id="save-username-btn" class="w-full max-w-xs p-4 bg-blue-500 hover:bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
            Namen speichern
        </button>
        <p id="username-message" class="text-center text-red-300 mt-4 text-sm hidden"></p>
    </div>

    <!-- Hauptmenü -->
    <div id="main-menu" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="game-title">Tic Tac Toe</h1>
        <button id="player-vs-player-btn" class="w-full max-w-xs p-4 mb-4 bg-green-500 hover:bg-green-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-green-700 active:border-b-0 active:translate-y-1">
            Spieler vs. Spieler
        </button>
        <button id="player-vs-bot-btn" class="w-full max-w-xs p-4 mb-4 bg-blue-500 hover:bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
            Spieler vs. Bot
        </button>
        <button id="player-vs-friend-btn" class="w-full max-w-xs p-4 mb-4 bg-purple-500 hover:bg-purple-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-purple-700 active:border-b-0 active:translate-y-1">
            Spieler vs. Freund
        </button>
        <button id="logout-btn" class="w-full max-w-xs p-4 bg-gray-600 hover:bg-gray-500 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-gray-800 active:border-b-0 active:translate-y-1">
            Abmelden
        </button>
    </div>

    <!-- Multiplayer Lobby Bildschirm -->
    <div id="multiplayer-lobby-screen" class="flex flex-col items-center justify-center p-8 bg-gray-700 rounded-lg shadow-lg hidden">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white mb-8 text-center" id="multiplayer-lobby-title">Multiplayer Lobby</h1>
        <p class="text-center text-white mb-4" id="your-code-text">Dein Freunde-Code:</p>
        <div class="text-3xl font-bold text-yellow-300 mb-6 p-3 bg-gray-800 rounded-md w-full max-w-xs text-center" id="your-friend-code">LÄDT...</div>
        
        <input type="text" id="friend-code-input" placeholder="Freunde-Code eingeben" class="w-full max-w-xs p-3 mb-4 rounded-lg bg-gray-600 text-white placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-purple-500">
        <button id="join-friend-game-btn" class="w-full max-w-xs p-4 mb-4 bg-purple-500 hover:bg-purple-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-purple-700 active:border-b-0 active:translate-y-1">
            Spiel beitreten
        </button>
        <div class="text-white mb-6" id="or-create-game-text">- ODER -</div>
        <button id="create-multiplayer-game-btn" class="w-full max-w-xs p-4 mb-6 bg-green-500 hover:bg-green-600 text-white text-xl font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-green-700 active:border-b-0 active:translate-y-1">
            Neues Multiplayer-Spiel starten
        </button>
        <p id="multiplayer-lobby-message" class="text-center text-red-300 mt-4 text-sm hidden"></p>
        <button id="back-from-lobby-btn" class="px-6 py-3 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-gray-800 active:border-b-0 active:translate-y-1">
            Zurück zum Menü
        </button>
    </div>


    <!-- Spielbereich -->
    <div id="game-area" class="flex-col items-center p-6 bg-gray-700 rounded-lg shadow-xl border-4 border-gray-900 hidden">
        <div id="status-display" class="text-center mb-4">
            <div id="current-player-text" class="text-2xl font-bold text-white">Aktueller Spieler: X</div>
            <div id="rank-info" class="text-xl font-bold text-white mt-2">
                Dein Rang: Bronze (0 Punkte)
                <p class="text-sm text-gray-300 mt-1" id="user-id-display"></p>
                <p class="text-sm text-gray-300 mt-1" id="username-display"></p>
            </div>
        </div>
        <div id="game-board-container" class="my-6 relative grid grid-cols-3 gap-2 p-4 bg-gray-500 border-4 border-gray-800 rounded-lg shadow-xl">
            <!-- Spielfelder werden hier durch JavaScript eingefügt -->
            <canvas id="particles-canvas" class="absolute inset-0 z-5"></canvas>
            <div id="winning-line-overlay" style="position: absolute; z-index: 10; transition: opacity 0.5s ease-out; opacity: 0;"></div>
            <div id="win-ring-overlay" class="hidden"></div> <!-- Win ring container -->
        </div>
        <div class="flex flex-col sm:flex-row gap-4 w-full justify-center">
            <button id="new-game-btn" class="px-6 py-3 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-red-700 active:border-b-0 active:translate-y-1">
                Neues Spiel
            </button>
            <button id="back-to-menu-btn" class="px-6 py-3 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 border-b-4 border-gray-800 active:border-b-0 active:translate-y-1">
                Zurück zum Menü
            </button>
        </div>
        <div id="bot-thinking-text" class="mt-4 text-white text-lg animate-pulse hidden">Bot denkt nach...</div>
    </div>

    <!-- Rangfortschritts-Overlay -->
    <div id="rank-progress-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-75 z-40 hidden">
        <div id="rank-progress-content" class="flex flex-col items-center p-8 bg-gray-800 rounded-lg shadow-2xl border-4 border-yellow-400">
            <h2 class="text-4xl sm:text-5xl font-extrabold text-white mb-4 text-center" id="rank-overlay-title">Dein Rang</h2>
            <div class="text-xl sm:text-2xl text-gray-300 mb-2">
                <span id="prev-rank-text">Vorheriger Rang: </span><span id="prev-rank-name" class="font-bold text-yellow-200"></span>
            </div>
            <div class="text-6xl sm:text-7xl font-extrabold text-yellow-300 animate-pulse my-4" id="animated-points">
                0
            </div>
            <div class="text-xl sm:text-2xl text-gray-300 mt-2">
                <span id="new-rank-text">Neuer Rang: </span><span id="new-rank-name" class="font-bold text-yellow-200"></span>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs & Game Logic Script -->
    <script type="module">
        // Firebase Konfiguration (von dir bereitgestellt)
        const firebaseConfig = {
            apiKey: "AIzaSyChEMvK_piOrCo9cYtt_mMDTjXd2R4_rU8",
            authDomain: "tictactoe-df871.firebaseapp.com",
            projectId: "tictactoe-df871",
            storageBucket: "tictactoe-df871.firebasestorage.app",
            messagingSenderId: "775114552044",
            appId: "1:775114552044:web:1c7198437e8b275ef66bc9",
            measurementId: "G-5030B21QRX"
        };

        // Firebase SDK Imports (aktualisiert auf Version 12.1.0)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

        // Globale Firebase-Variablen
        window.firebaseApp = null;
        window.firebaseAuth = null;
        window.firebaseDb = null;
        window.currentUserId = null;
        window.isFirebaseReady = false;
        window.userRankPoints = 0; // Initialisiere globale Rangpunkte
        window.userRankName = 'Bronze'; // Initialisiere globalen Rangnamen
        window.userDisplayName = null; // Um den gewählten Benutzernamen zu speichern
        window.userFriendCode = null; // Der eindeutige Freundes-Code des Benutzers
        let currentScreen = 'auth'; // 'auth', 'username', 'mainMenu', 'multiplayerLobby', 'game'

        // Multiplayer-spezifische Variablen
        let currentMultiplayerGameRef = null; // Firestore Doc Ref für das aktuelle MP-Spiel
        let gameSessionUnsubscribe = null; // Funktion zum Beenden des onSnapshot Listeners
        let isPlayerX = false; // Ist der aktuelle Spieler Spieler X in einem MP-Spiel?


        // Hilfsfunktion, um die Firebase Konfiguration zu laden.
        const getFirebaseConfig = () => {
            return firebaseConfig; // Direkt die bereitgestellte Konfiguration zurückgeben
        };

        // Hilfsfunktion, um die App-ID zu bekommen.
        // Für statische Bereitstellungen verwenden wir projectId als App ID für den Firestore-Pfad
        const getAppId = () => {
            return firebaseConfig.projectId;
        };

        // Translations (globally accessible)
        window.translations = {
            de: {
                gameTitle: "Tic Tac Toe",
                playerVsPlayer: "Spieler vs. Spieler",
                playerVsBot: "Spieler vs. Bot",
                playerVsFriend: "Spieler vs. Freund", // Neu
                newGame: "Neues Spiel",
                backToMenu: "Zurück zum Menü",
                currentPlayer: "Aktueller Spieler",
                winner: "Gewinner",
                draw: "Unentschieden!",
                botThinking: "Bot denkt nach...",
                yourRank: "Dein Rang",
                points: "Punkte",
                loadingRank: "Rang wird geladen...",
                rankBronze: "Bronze",
                rankSilver: "Silber",
                rankGold: "Gold",
                rankPlatinum: "Platin",
                rankDiamond: "Diamant",
                previousRank: "Vorheriger Rang",
                newRank: "Neuer Rang",
                authTitle: "Anmelden / Registrieren",
                emailPlaceholder: "E-Mail",
                passwordPlaceholder: "Passwort",
                loginBtn: "Anmelden",
                signupBtn: "Registrieren",
                or: "- ODER -",
                googleSignIn: "Mit Google anmelden",
                authError: "Fehler bei der Authentifizierung: ",
                usernameTitle: "Wähle deinen Namen",
                usernamePrompt: "Bevor du spielst, gib bitte einen Namen ein:",
                usernamePlaceholder: "Dein Name",
                saveUsernameBtn: "Namen speichern",
                usernameError: "Fehler: ",
                logoutBtn: "Abmelden",
                loggedInAs: "Angemeldet als:",
                multiplayerLobbyTitle: "Multiplayer Lobby", // Neu
                yourCodeText: "Dein Freunde-Code:", // Neu
                friendCodeInputPlaceholder: "Freunde-Code eingeben", // Neu
                joinGameBtn: "Spiel beitreten", // Neu
                orCreateGameText: "- ODER -", // Neu
                createMultiplayerGameBtn: "Neues Multiplayer-Spiel starten", // Neu
                lobbyMessageWaiting: "Warte auf Spieler O...", // Neu
                lobbyMessageJoined: "Spiel beigetreten. Warte auf Start...", // Neu
                lobbyMessageError: "Fehler in der Lobby: ", // Neu
                gameAlreadyStarted: "Das Spiel hat bereits begonnen oder ist voll.", // Neu
                gameNotFound: "Spiel nicht gefunden oder Code ungültig.", // Neu
                gameJoinedSuccess: "Spiel erfolgreich beigetreten!", // Neu
                gameCreatedSuccess: "Multiplayer-Spiel erstellt! Teile deinen Code.", // Neu
            },
            en: {
                gameTitle: "Tic Tac Toe",
                playerVsPlayer: "Player vs. Player",
                playerVsBot: "Player vs. Bot",
                playerVsFriend: "Player vs. Friend", // New
                newGame: "New Game",
                backToMenu: "Back to Menu",
                currentPlayer: "Current Player",
                winner: "Winner",
                draw: "It's a Draw!",
                botThinking: "Bot is thinking...",
                yourRank: "Your Rank",
                points: "Points",
                loadingRank: "Loading rank...",
                rankBronze: "Bronze",
                rankSilver: "Silver",
                rankGold: "Gold",
                rankPlatinum: "Platinum",
                rankDiamond: "Diamond",
                previousRank: "Previous Rank",
                newRank: "New Rank",
                authTitle: "Sign In / Sign Up",
                emailPlaceholder: "Email",
                passwordPlaceholder: "Password",
                loginBtn: "Sign In",
                signupBtn: "Sign Up",
                or: "- OR -",
                googleSignIn: "Sign in with Google",
                authError: "Authentication error: ",
                usernameTitle: "Choose Your Name",
                usernamePrompt: "Before you play, please enter a name:",
                usernamePlaceholder: "Your Name",
                saveUsernameBtn: "Save Name",
                usernameError: "Error: ",
                logoutBtn: "Log Out",
                loggedInAs: "Logged in as:",
                multiplayerLobbyTitle: "Multiplayer Lobby", // New
                yourCodeText: "Your Friend Code:", // New
                friendCodeInputPlaceholder: "Enter Friend Code", // New
                joinGameBtn: "Join Game", // New
                orCreateGameText: "- OR -", // New
                createMultiplayerGameBtn: "Start New Multiplayer Game", // New
                lobbyMessageWaiting: "Waiting for Player O...", // New
                lobbyMessageJoined: "Game joined. Waiting for start...", // New
                lobbyMessageError: "Lobby Error: ", // New
                gameAlreadyStarted: "Game has already started or is full.", // New
                gameNotFound: "Game not found or invalid code.", // New
                gameJoinedSuccess: "Game joined successfully!", // New
                gameCreatedSuccess: "Multiplayer game created! Share your code.", // New
            },
        };

        // Game State Variables
        let board = Array(9).fill(null);
        let currentPlayer = 'X';
        let winner = null;
        let winningLine = null;
        let isBotTurn = false;
        let gameMode = 'mainMenu'; // 'mainMenu', 'playerVsPlayer', 'playerVsBot', 'playerVsFriend'
        
        let language = 'de'; // Default language

        // Particle animation variables
        let particles = [];
        let animationFrameId = null;
        let canvas = null;
        let ctx = null;

        // Dom Elements (declared here, assigned in DOMContentLoaded)
        let mainMenuDiv, gameAreaDiv, boardContainerDiv, playerVsPlayerBtn, playerVsBotBtn, playerVsFriendBtn,
            newGameBtn, backToMenuBtn, currentPlayerText, botThinkingText,
            languageToggleBtn, currentLanguageDisplay, gameTitleDisplay,
            rankInfoDisplay, userIdDisplay, winningLineOverlay, winRingOverlay,
            rankProgressOverlay, rankOverlayTitle, prevRankText, newRankText, animatedPointsDisplay,
            authScreenDiv, emailInput, passwordInput, loginBtn, signupBtn, googleSignInBtn, authMessageDisplay, authOrText,
            usernameScreenDiv, usernameInput, saveUsernameBtn, usernameMessageDisplay,
            authTitleDisplay, usernameTitleDisplay, usernamePromptDisplay, logoutBtn,
            profileDisplay, usernameInProfile, rankNameInProfile, rankProgressBarFill, rankPointsInProfile,
            multiplayerLobbyScreen, multiplayerLobbyTitle, yourCodeText, yourFriendCodeDisplay, friendCodeInput, joinFriendGameBtn, orCreateGameText, createMultiplayerGameBtn, multiplayerLobbyMessage, backFromLobbyBtn;

        // --- Utility Functions ---
        // Get current translation object
        const t = () => window.translations[language];

        // Function to get rank name (globalized to be accessible for Firebase part)
        window.getRankName = (points) => {
            const currentTranslations = t(); // Use the current translation object
            if (points >= 400) return currentTranslations.rankDiamond;
            if (points >= 300) return currentTranslations.rankPlatinum;
            if (points >= 200) return currentTranslations.rankGold;
            if (points >= 100) return currentTranslations.rankSilver;
            return currentTranslations.rankBronze;
        };

        // Funktion zur Berechnung des Rangfortschritts (Punkte innerhalb des aktuellen Rangs)
        const getRankProgressDetails = (points) => {
            let basePoints = 0;
            let nextRankPoints = 100;
            if (points >= 400) { // Diamond
                basePoints = 400;
                nextRankPoints = 400; // No next rank beyond Diamond for now
            } else if (points >= 300) { // Platinum
                basePoints = 300;
                nextRankPoints = 400;
            } else if (points >= 200) { // Gold
                basePoints = 200;
                nextRankPoints = 300;
            } else if (points >= 100) { // Silver
                basePoints = 100;
                nextRankPoints = 200;
            }
            const pointsInCurrentRank = points - basePoints;
            const pointsToNextRank = nextRankPoints - basePoints;
            const progressPercentage = pointsToNextRank > 0 ? (pointsInCurrentRank / pointsToNextRank) * 100 : 100;

            return {
                pointsInCurrentRank,
                pointsToNextRank,
                progressPercentage: Math.min(100, progressPercentage) // Clamp to 100%
            };
        };

        // --- UI Update Functions (defined early to be accessible) ---
        function updateTextContent() {
            // Main Menu
            if (gameTitleDisplay) gameTitleDisplay.textContent = t().gameTitle;
            if (playerVsPlayerBtn) playerVsPlayerBtn.textContent = t().playerVsPlayer;
            if (playerVsBotBtn) playerVsBotBtn.textContent = t().playerVsBot;
            if (playerVsFriendBtn) playerVsFriendBtn.textContent = t().playerVsFriend;
            if (newGameBtn) newGameBtn.textContent = t().newGame;
            if (backToMenuBtn) backToMenuBtn.textContent = t().backToMenu;
            if (logoutBtn) logoutBtn.textContent = t().logoutBtn;

            // Game Area / Status
            if (botThinkingText) botThinkingText.textContent = t().botThinking;
            
            // Language Toggle
            if (languageToggleBtn) languageToggleBtn.title = language === 'de' ? 'Sprache wechseln' : 'Change language';
            if (currentLanguageDisplay) currentLanguageDisplay.textContent = language.toUpperCase();

            // Rank Overlay
            if (rankOverlayTitle) rankOverlayTitle.textContent = t().yourRank;
            if (prevRankText) prevRankText.textContent = t().previousRank + ": ";
            if (newRankText) newRankText.textContent = t().newRank + ": ";

            // Auth Screen
            if (authTitleDisplay) authTitleDisplay.textContent = t().authTitle;
            if (emailInput) emailInput.placeholder = t().emailPlaceholder;
            if (passwordInput) passwordInput.placeholder = t().passwordPlaceholder;
            if (loginBtn) loginBtn.textContent = t().loginBtn;
            if (signupBtn) signupBtn.textContent = t().signupBtn;
            if (authOrText) authOrText.textContent = t().or;
            if (googleSignInBtn) googleSignInBtn.innerHTML = `<svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12.0003 4.75C14.0003 4.75 15.5803 5.43 16.7303 6.54L19.2603 4.01C17.5803 2.33 15.0003 1.5 12.0003 1.5C8.30029 1.5 5.01029 3.51 3.32029 6.52L6.34029 8.87C7.14029 6.55 9.38029 4.75 12.0003 4.75V4.75ZM20.5303 12.00C20.5303 11.23 20.4603 10.45 20.3203 9.69H12.0003V14.31H16.9203C16.7203 15.39 16.0303 16.29 15.0603 16.93L17.9703 19.26C19.6403 17.58 20.5303 15.00 20.5303 12.00V12.00ZM6.34029 15.13L3.32029 17.48C5.01029 20.49 8.30029 22.5 12.0003 22.5C15.0003 22.5 17.5803 21.67 19.2603 19.99L16.7303 17.46C15.5803 18.57 14.0003 19.25 12.0003 19.25C9.38029 19.25 7.14029 17.45 6.34029 15.13Z" fill="#FFF"></path></svg> ${t().googleSignIn}`;
            
            // Username Screen
            if (usernameTitleDisplay) usernameTitleDisplay.textContent = t().usernameTitle;
            if (usernamePromptDisplay) usernamePromptDisplay.textContent = t().usernamePrompt;
            if (usernameInput) usernameInput.placeholder = t().usernamePlaceholder;
            if (saveUsernameBtn) saveUsernameBtn.textContent = t().saveUsernameBtn;

            // Multiplayer Lobby Screen
            if (multiplayerLobbyTitle) multiplayerLobbyTitle.textContent = t().multiplayerLobbyTitle;
            if (yourCodeText) yourCodeText.textContent = t().yourCodeText;
            if (yourFriendCodeDisplay) yourFriendCodeDisplay.textContent = window.userFriendCode || 'LÄDT...';
            if (friendCodeInput) friendCodeInput.placeholder = t().friendCodeInputPlaceholder;
            if (joinFriendGameBtn) joinFriendGameBtn.textContent = t().joinGameBtn;
            if (orCreateGameText) orCreateGameText.textContent = t().orCreateGameText;
            if (createMultiplayerGameBtn) createMultiplayerGameBtn.textContent = t().createMultiplayerGameBtn;
            if (backFromLobbyBtn) backFromLobbyBtn.textContent = t().backToMenu;


            updateStatusDisplay(); // Also update status display with new language
        }

        function updateStatusDisplay() {
            let statusText = '';
            if (winner) {
                if (winner === 'Unentschieden') {
                    statusText = t().draw;
                    if (currentPlayerText) currentPlayerText.className = "text-3xl font-bold text-yellow-300";
                } else {
                    statusText = `${t().winner}: ${winner}!`;
                    if (currentPlayerText) currentPlayerText.className = "text-3xl font-bold text-green-400";
                }
            } else {
                statusText = `${t().currentPlayer}: ${currentPlayer}`;
                if (currentPlayerText) currentPlayerText.className = "text-2xl font-bold text-white";
            }
            if (currentPlayerText) currentPlayerText.textContent = statusText;

            // Update main rank info display (in game area)
            if (window.isFirebaseReady && rankInfoDisplay && userIdDisplay) {
                rankInfoDisplay.innerHTML = `${t().yourRank}: ${window.userRankName} (${window.userRankPoints} ${t().points})`;
                userIdDisplay.textContent = `User ID: ${window.currentUserId || 'N/A'}`;
                const usernameDisplayElement = document.getElementById('username-display');
                if (usernameDisplayElement) {
                    usernameDisplayElement.textContent = `${t().loggedInAs} ${window.userDisplayName || 'Gast'}`;
                }
                rankInfoDisplay.style.display = 'block';
                userIdDisplay.style.display = 'block';
                if (usernameDisplayElement) usernameDisplayElement.style.display = 'block';

            } else if (rankInfoDisplay) {
                rankInfoDisplay.textContent = t().loadingRank;
                if (userIdDisplay) userIdDisplay.textContent = '';
                const usernameDisplayElement = document.getElementById('username-display');
                if(usernameDisplayElement) usernameDisplayElement.textContent = '';
                rankInfoDisplay.style.display = 'block';
            }

            // Update profile display (top-left corner)
            if (profileDisplay && window.isFirebaseReady) {
                if (usernameInProfile) usernameInProfile.textContent = window.userDisplayName || 'Gast';
                if (rankNameInProfile) rankNameInProfile.textContent = window.userRankName;
                if (rankPointsInProfile) {
                    const progress = getRankProgressDetails(window.userRankPoints);
                    if (progress.pointsToNextRank === 0) { // Max rank reached
                        rankPointsInProfile.textContent = `${window.userRankPoints} ${t().points}`;
                    } else {
                        rankPointsInProfile.textContent = `${progress.pointsInCurrentRank}/${progress.pointsToNextRank} ${t().points}`;
                    }
                }
                if (rankProgressBarFill) {
                    const progress = getRankProgressDetails(window.userRankPoints);
                    rankProgressBarFill.style.width = `${progress.progressPercentage}%`;
                }
            }
        }

        function showAuthMessage(message, isError = true) {
            if (authMessageDisplay) {
                authMessageDisplay.textContent = (isError ? t().authError : '') + message;
                authMessageDisplay.classList.remove('hidden');
                authMessageDisplay.classList.toggle('text-red-300', isError);
                authMessageDisplay.classList.toggle('text-green-300', !isError);
            }
        }

        function hideAuthMessage() {
            if (authMessageDisplay) {
                authMessageDisplay.classList.add('hidden');
            }
        }

        function showUsernameMessage(message, isError = true) {
            if (usernameMessageDisplay) {
                usernameMessageDisplay.textContent = (isError ? t().usernameError : '') + message;
                usernameMessageDisplay.classList.remove('hidden');
                usernameMessageDisplay.classList.toggle('text-red-300', isError);
                usernameMessageDisplay.classList.toggle('text-green-300', !isError);
            }
        }

        function hideUsernameMessage() {
            if (usernameMessageDisplay) {
                usernameMessageDisplay.classList.add('hidden');
            }
        }

        function showMultiplayerLobbyMessage(message, isError = true) {
            if (multiplayerLobbyMessage) {
                multiplayerLobbyMessage.textContent = (isError ? t().lobbyMessageError : '') + message;
                multiplayerLobbyMessage.classList.remove('hidden');
                multiplayerLobbyMessage.classList.toggle('text-red-300', isError);
                multiplayerLobbyMessage.classList.toggle('text-green-300', !isError);
            }
        }

        function hideMultiplayerLobbyMessage() {
            if (multiplayerLobbyMessage) {
                multiplayerLobbyMessage.classList.add('hidden');
            }
        }

        function renderScreen(screenName) {
            mainMenuDiv.classList.add('hidden');
            gameAreaDiv.classList.add('hidden');
            authScreenDiv.classList.add('hidden');
            usernameScreenDiv.classList.add('hidden');
            multiplayerLobbyScreen.classList.add('hidden'); // New screen
            if (profileDisplay) profileDisplay.classList.add('hidden'); // Hide profile by default

            switch (screenName) {
                case 'auth':
                    authScreenDiv.classList.remove('hidden');
                    break;
                case 'username':
                    usernameScreenDiv.classList.remove('hidden');
                    break;
                case 'mainMenu':
                    mainMenuDiv.classList.remove('hidden');
                    if (profileDisplay && window.isFirebaseReady && window.userDisplayName) profileDisplay.classList.remove('hidden');
                    break;
                case 'multiplayerLobby': // New case
                    multiplayerLobbyScreen.classList.remove('hidden');
                    if (profileDisplay && window.isFirebaseReady && window.userDisplayName) profileDisplay.classList.remove('hidden');
                    break;
                case 'game':
                    gameAreaDiv.classList.remove('hidden');
                    if (profileDisplay && window.isFirebaseReady && window.userDisplayName) profileDisplay.classList.remove('hidden');
                    break;
            }
            currentScreen = screenName;
            updateTextContent(); // Ensure texts are correct for the new screen
        }
        
        // --- Firebase-related Functions ---
        window.initializeFirebase = async () => {
            try {
                const fConfig = getFirebaseConfig();
                window.firebaseApp = initializeApp(fConfig);
                window.firebaseAuth = getAuth(window.firebaseApp);
                window.firebaseDb = getFirestore(window.firebaseApp);

                onAuthStateChanged(window.firebaseAuth, async (user) => {
                    if (user) {
                        window.currentUserId = user.uid;
                        window.isFirebaseReady = true;
                        console.log("Firebase: User authenticated:", user.uid);
                        // Check for user's display name and friend code
                        await checkUserDisplayName(user.uid);
                        window.subscribeToRankChanges(); // Subscribe only after user and name are checked
                    } else {
                        window.currentUserId = null;
                        window.isFirebaseReady = false;
                        window.userDisplayName = null; // Clear display name on logout
                        window.userFriendCode = null; // Clear friend code on logout
                        console.log("Firebase: User signed out or not authenticated.");
                        renderScreen('auth'); // Go to auth screen if not authenticated
                    }
                    updateStatusDisplay(); // Update UI
                });
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                window.isFirebaseReady = false;
                showAuthMessage("Firebase-Initialisierungsfehler: " + error.message);
            }
        };

        async function generateFriendCode() {
            // Simple deterministic code for demo based on user ID
            if (window.currentUserId) {
                return window.currentUserId.substring(0, 6).toUpperCase();
            }
            return null;
        }

        async function checkUserDisplayName(uid) {
            if (!window.firebaseDb) return;
            const profileDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${uid}/profile`, 'userProfile');
            try {
                const docSnap = await getDoc(profileDocRef);
                if (docSnap.exists() && docSnap.data().displayName) {
                    window.userDisplayName = docSnap.data().displayName;
                    window.userFriendCode = docSnap.data().friendCode || await generateFriendCode(); // Get existing or generate
                    if (!docSnap.data().friendCode) { // If code was just generated, save it
                        await setDoc(profileDocRef, { friendCode: window.userFriendCode }, { merge: true });
                    }
                    console.log("User Display Name:", window.userDisplayName, "Friend Code:", window.userFriendCode);
                    renderScreen('mainMenu'); // Go to main menu if name exists
                } else {
                    window.userDisplayName = null;
                    window.userFriendCode = null;
                    renderScreen('username'); // Go to username screen if no name
                }
            } catch (error) {
                console.error("Error fetching user profile:", error);
                showUsernameMessage("Fehler beim Laden des Profils: " + error.message);
                renderScreen('username'); // Fallback to username screen on error
            }
        }


        window.subscribeToRankChanges = () => {
            if (!window.isFirebaseReady || !window.currentUserId || !window.firebaseDb) {
                console.warn("Cannot subscribe to rank changes: Firebase not ready or user ID missing.");
                return;
            }

            const rankDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/rank`, 'playerRank');

            window.rankUnsubscribe = onSnapshot(rankDocRef, (docSnap) => {
                let newPoints = 0;
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    newPoints = data.points;
                } else {
                    // Rang initialisieren, wenn er nicht existiert
                    const initialPoints = 0;
                    setDoc(rankDocRef, { points: initialPoints }).catch(error => console.error("Error setting initial rank:", error));
                    newPoints = initialPoints;
                }

                const oldPoints = window.userRankPoints; // Use the current global value
                const oldRankName = window.getRankName(oldPoints);
                const newRankName = window.getRankName(newPoints);

                if (newPoints !== oldPoints || newRankName !== oldRankName) {
                    // Trigger the rank progress display
                    window.showRankProgressOverlay(oldPoints, newPoints, oldRankName, newRankName);
                    
                    // Trigger the subtle pop animation on the rank text in the status bar
                    if (document.getElementById('rank-info')) {
                      document.getElementById('rank-info').classList.add('animate-rank-pop');
                      setTimeout(() => {
                          document.getElementById('rank-info').classList.remove('animate-rank-pop');
                      }, 500);
                    }
                }
                
                window.userRankPoints = newPoints;
                window.userRankName = newRankName;
                updateStatusDisplay(); // Update status bar with new rank info
            }, (error) => {
                console.error("Error listening to rank:", error);
            });
        };

        window.updatePlayerRank = async (gameOutcome) => {
            if (!window.firebaseDb || !window.currentUserId || gameMode !== 'playerVsBot') {
                console.log("Not in bot mode or Firestore/User ID not ready. Rank will not be updated.");
                return;
            }

            const rankDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/rank`, 'playerRank');
            let newPoints = window.userRankPoints;

            switch (gameOutcome) {
                case 'win':
                    newPoints += 20;
                    break;
                case 'loss':
                    newPoints = Math.max(0, newPoints - 10);
                    break;
                case 'draw':
                    newPoints += 5;
                    break;
                default:
                    break;
            }

            try {
                await updateDoc(rankDocRef, { points: newPoints });
            } catch (error) {
                console.error("Error updating rank:", error);
            }
        };

        window.showRankProgressOverlay = (oldP, newP, oldR, newR) => {
            const overlay = document.getElementById('rank-progress-overlay');
            const overlayContent = document.getElementById('rank-progress-content');
            
            if (!overlay || !overlayContent || !animatedPointsDisplay || !prevRankText || !newRankText || !rankOverlayTitle) {
                console.error("Rank progress overlay elements not found. Cannot show animation.");
                return;
            }

            // Set initial points for animation
            let animatedPoints = oldP;
            overlayContent.querySelector('#prev-rank-name').textContent = oldR;
            overlayContent.querySelector('#new-rank-name').textContent = newR;
            animatedPointsDisplay.textContent = Math.round(animatedPoints); // Use the global animatedPointsDisplay

            overlay.classList.remove('hidden');
            overlay.classList.add('animate-overlay-fade-in');
            overlayContent.classList.remove('scale-0'); // Ensure it's not scaled down from previous animation
            overlayContent.classList.add('animate-rank-overlay-enter');

            let start = null;
            const duration = 2000; // 2 seconds for animation

            const animatePoints = (currentTime) => {
                if (!start) start = currentTime;
                const progress = (currentTime - start) / duration;

                if (progress < 1) {
                    const easedProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
                    const current = oldP + (newP - oldP) * easedProgress;
                    animatedPointsDisplay.textContent = Math.round(current);
                    requestAnimationFrame(animatePoints);
                } else {
                    animatedPointsDisplay.textContent = newP;
                    // Hide after a total of 4 seconds
                    setTimeout(() => {
                        overlay.classList.add('hidden');
                        overlay.classList.remove('animate-overlay-fade-in');
                        overlayContent.classList.remove('animate-rank-overlay-enter');
                    }, 2000); // 2 seconds after point animation finishes
                }
            };
            requestAnimationFrame(animatePoints);
        };

        // --- Game Logic Functions ---
        function calculateWinner(squares) {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6],
            ];
            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
                    return { winner: squares[a], line: lines[i] };
                }
            }
            return { winner: null, line: null };
        }

        async function handleSquareClick(i) {
            if (winner || board[i] || (gameMode === 'playerVsBot' && isBotTurn)) {
                return;
            }

            if (gameMode === 'playerVsFriend') {
                if (!currentMultiplayerGameRef || !window.currentUserId) {
                    showMultiplayerLobbyMessage("Fehler: Kein Multiplayer-Spiel aktiv.", true);
                    return;
                }
                // Only allow moves if it's your turn
                if ((isPlayerX && currentPlayer === 'X') || (!isPlayerX && currentPlayer === 'O')) {
                    const newBoard = [...board];
                    newBoard[i] = currentPlayer;

                    const { winner: potentialWinner, line: winningLineFound } = calculateWinner(newBoard);
                    let newGameStatus = 'playing';
                    let gameOutcome = null;

                    if (potentialWinner) {
                        newGameStatus = 'finished';
                        gameOutcome = potentialWinner;
                    } else if (newBoard.every(square => square !== null)) {
                        newGameStatus = 'finished';
                        gameOutcome = 'Unentschieden';
                    }

                    await updateGameSession({
                        board: newBoard,
                        currentPlayer: currentPlayer === 'X' ? 'O' : 'X',
                        winner: gameOutcome,
                        winningLine: winningLineFound,
                        status: newGameStatus
                    });
                } else {
                    // It's not your turn
                    showMultiplayerLobbyMessage("Warte auf den Zug des anderen Spielers.", false);
                }
                return; // Exit as logic is handled by Firestore listener
            }

            // --- Local Game Logic (Player vs Player / Player vs Bot) ---
            board[i] = currentPlayer;
            
            const { winner: potentialWinner, line: winningLineFound } = calculateWinner(board);
            if (potentialWinner) {
                winner = potentialWinner;
                winningLine = winningLineFound;
                if (winner !== 'Unentschieden') {
                    triggerWinRingAnimation();
                }
                if (gameMode === 'playerVsBot') {
                    if (winner === currentPlayer) { // CurrentPlayer is the human who just made the move
                        window.updatePlayerRank('win');
                    } else {
                        window.updatePlayerRank('loss');
                    }
                }
                renderBoard(); // Render final state immediately after win/draw
                updateStatusDisplay();
            } else if (board.every(square => square !== null)) {
                winner = 'Unentschieden';
                winningLine = null;
                if (gameMode === 'playerVsBot') {
                    window.updatePlayerRank('draw');
                }
                renderBoard(); // Render final state immediately after win/draw
                updateStatusDisplay();
            } else {
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                renderBoard(); // Render board after player's valid move, before bot's turn
                updateStatusDisplay();
            }
            
            // Only trigger bot's turn if no winner/draw after player's move
            if (gameMode === 'playerVsBot' && currentPlayer === 'O' && !winner) {
                isBotTurn = true;
                if (botThinkingText) botThinkingText.classList.remove('hidden');
                renderBoard(); // Re-render to disable squares while bot is thinking
                setTimeout(() => {
                    makeBotMove(); // This function now only updates game state
                    isBotTurn = false; // Bot's turn is over
                    if (botThinkingText) botThinkingText.classList.add('hidden');
                    renderBoard(); // Re-render to enable squares if no winner/draw after bot's move
                    updateStatusDisplay(); // Update status display after bot's move
                }, 2000); // Bot thinking delay
            }
        }

        function makeBotMove() {
            if (winner) return; // Should not happen if called correctly

            const emptySquares = board.map((val, idx) => val === null ? idx : null).filter(val => val !== null);
            if (emptySquares.length === 0) return;

            let botMoveIndex = -1;

            // 1. Check if bot can win
            for (let i = 0; i < emptySquares.length; i++) {
                const tempBoard = [...board];
                tempBoard[emptySquares[i]] = 'O';
                const { winner: tempWinner } = calculateWinner(tempBoard);
                if (tempWinner === 'O') {
                    botMoveIndex = emptySquares[i];
                    break;
                }
            }

            // 2. Check if player can win and block
            if (botMoveIndex === -1) {
                for (let i = 0; i < emptySquares.length; i++) {
                    const tempBoard = [...board];
                    tempBoard[emptySquares[i]] = 'X';
                    const { winner: tempWinner } = calculateWinner(tempBoard);
                    if (tempWinner === 'X') {
                        botMoveIndex = emptySquares[i];
                        break;
                    }
                }
            }

            // 3. Take center if available
            if (botMoveIndex === -1 && board[4] === null) {
                botMoveIndex = 4;
            }

            // 4. Take a corner if available
            if (botMoveIndex === -1) {
                const corners = [0, 2, 6, 8].filter(idx => board[idx] === null);
                if (corners.length > 0) {
                    botMoveIndex = corners[Math.floor(Math.random() * corners.length)];
                }
            }

            // 5. Take any empty square
            if (botMoveIndex === -1) {
                const randomIndex = Math.floor(Math.random() * emptySquares.length);
                botMoveIndex = emptySquares[randomIndex];
            }

            board[botMoveIndex] = 'O'; // Bot makes its move
            
            const { winner: potentialWinner, line: winningLineFound } = calculateWinner(board);
            if (potentialWinner) {
                winner = potentialWinner;
                winningLine = winningLineFound;
                if (winner !== 'Unentschieden') {
                    triggerWinRingAnimation();
                }
                if (gameMode === 'playerVsBot') {
                    if (winner === 'O') { // Bot ('O') won
                        window.updatePlayerRank('loss'); // Human player ('X') lost
                    } else {
                        // This case (X winning after O's move) should ideally not happen if bot logic is sound,
                        // but if it does, it's a win for the player from the game's perspective.
                        window.updatePlayerRank('win');
                    }
                }
            } else if (board.every(square => square !== null)) {
                winner = 'Unentschieden';
                winningLine = null;
                if (gameMode === 'playerVsBot') {
                    window.updatePlayerRank('draw');
                }
            } else {
                currentPlayer = 'X'; // After bot's move, it's always player 'X's turn
            }

            // IMPORTANT: renderBoard() and updateStatusDisplay() are now called in the setTimeout callback
            // in handleSquareClick, AFTER isBotTurn is set to false.
        }

        // Changed to const arrow function to prevent redeclaration error
        const resetGame = () => {
            board = Array(9).fill(null);
            currentPlayer = 'X';
            winner = null;
            winningLine = null;
            isBotTurn = false;
            if (botThinkingText) botThinkingText.classList.add('hidden');
            if (gameSessionUnsubscribe) { // Unsubscribe from multiplayer game if active
                gameSessionUnsubscribe();
                gameSessionUnsubscribe = null;
            }
            currentMultiplayerGameRef = null;
            isPlayerX = false;
            renderBoard();
            updateStatusDisplay();
            if (winRingOverlay) winRingOverlay.classList.add('hidden'); // Ensure ring is hidden
        };

        // Changed to const arrow function to prevent redeclaration error
        const backToMainMenu = () => {
            resetGame();
            renderScreen('mainMenu');
        };

        // --- Animation Functions ---
        function drawWinningLine() {
            if (!winningLine || !boardContainerDiv || !winningLineOverlay) {
                if (winningLineOverlay) winningLineOverlay.style.opacity = '0';
                return;
            }

            const lineThickness = 8; // in Pixeln
            const boardPaddingPx = 16; // 1rem = 16px (for p-4)

            const boardRect = boardContainerDiv.getBoundingClientRect();
            const effectiveGridWidth = boardRect.width - (2 * boardPaddingPx);
            const effectiveGridHeight = boardRect.height - (2 * boardPaddingPx);

            const cellWidth = effectiveGridWidth / 3;
            const cellHeight = effectiveGridHeight / 3;

            const getSquareCenter = (squareIndex) => {
                const row = Math.floor(squareIndex / 3);
                const col = squareIndex % 3;
                const centerX = boardPaddingPx + col * cellWidth + cellWidth / 2;
                const centerY = boardPaddingPx + row * cellHeight + cellHeight / 2;
                return { x: centerX, y: centerY };
            };

            const startCellIndex = winningLine[0];
            const endCellIndex = winningLine[2]; 

            const startCenter = getSquareCenter(startCellIndex);
            const endCenter = getSquareCenter(endCellIndex);

            const dx = endCenter.x - startCenter.x;
            const dy = endCenter.y - startCenter.y;

            const lineLength = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            const midX = (startCenter.x + endCenter.x) / 2;
            const midY = (startCenter.y + endCenter.y) / 2;

            winningLineOverlay.style.cssText = `
                background-color: rgb(34, 197, 94);
                border-radius: 9999px;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                position: absolute;
                z-index: 10;
                transition: opacity 0.5s ease-out;
                opacity: 1; /* Make visible for animation */
                width: ${lineLength}px;
                height: ${lineThickness}px;
                left: ${midX - lineLength / 2}px;
                top: ${midY - lineThickness / 2}px;
                transform-origin: center center;
                transform: rotate(${angle}deg);
            `;

            // Particle animation
            startParticleAnimation();
        }

        let particlesAnimationFrameId = null;
        let particleArray = [];

        function startParticleAnimation() {
            if (particlesAnimationFrameId) cancelAnimationFrame(particlesAnimationFrameId); // Stop existing animation

            if (!canvas || !ctx || !boardContainerDiv || !winningLine) {
                console.warn("Cannot start particle animation: Missing required elements or winningLine.");
                return;
            }

            const boardRect = boardContainerDiv.getBoundingClientRect();
            canvas.width = boardRect.width;
            canvas.height = boardRect.height;

            particleArray = []; // Clear previous particles
            const boardPaddingPx = 16;
            const effectiveGridWidth = boardRect.width - (2 * boardPaddingPx);
            const effectiveGridHeight = boardRect.height - (2 * boardPaddingPx);
            const cellWidth = effectiveGridWidth / 3;
            const cellHeight = effectiveGridHeight / 3;

            winningLine.forEach(squareIndex => {
                const row = Math.floor(squareIndex / 3);
                const col = squareIndex % 3;
                const centerX = boardPaddingPx + col * cellWidth + cellWidth / 2;
                const centerY = boardPaddingPx + row * cellHeight + cellHeight / 2;

                for (let i = 0; i < 15; i++) {
                    particleArray.push({ // Using particleArray here, consistent with declaration
                        x: centerX,
                        y: centerY,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 0,
                        maxLife: 60 + Math.random() * 30,
                        radius: 2 + Math.random() * 2,
                        color: '0, 255, 0'
                    });
                }
            });

            const animateParticles = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < particleArray.length; i++) { // Using particleArray here
                    const p = particleArray[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life++;

                    const alpha = 1 - (p.life / p.maxLife);
                    const currentRadius = p.radius * Math.max(0.01, alpha);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, currentRadius, 0, Math.PI * 2, false);
                    ctx.fillStyle = `rgba(${p.color}, ${alpha})`;
                    ctx.fill();

                    if (p.life >= p.maxLife) {
                        particleArray.splice(i, 1);
                        i--;
                    }
                }
                if (particleArray.length > 0) { // Check 'particleArray' length
                    animationFrameId = requestAnimationFrame(animateParticles);
                } else {
                    animationFrameId = null; // Animation finished
                }
            };
            animationFrameId = requestAnimationFrame(animateParticles); // Use general animationFrameId
        }

        let winRingAnimationTimeout = null;
        function triggerWinRingAnimation() {
            if (!winRingOverlay) {
                console.warn("winRingOverlay element not found. Cannot trigger win ring animation.");
                return;
            }
            // Clear any existing animation before starting a new one
            if (winRingAnimationTimeout) clearTimeout(winRingAnimationTimeout);
            
            winRingOverlay.classList.remove('hidden');
            // Remove and re-add the class to re-trigger the animation
            winRingOverlay.classList.remove('win-ring');
            void winRingOverlay.offsetWidth; // Trigger reflow to restart animation
            winRingOverlay.classList.add('win-ring');

            winRingAnimationTimeout = setTimeout(() => {
                winRingOverlay.classList.add('hidden');
            }, 1000); // Duration of the animation
        }


        // --- Authentication Event Handlers ---
        async function handleEmailLogin() {
            hideAuthMessage();
            const email = emailInput.value;
            const password = passwordInput.value;
            if (!email || !password) {
                showAuthMessage("Bitte E-Mail und Passwort eingeben.");
                return;
            }
            try {
                await signInWithEmailAndPassword(window.firebaseAuth, email, password);
                // onAuthStateChanged will handle screen transition
            } catch (error) {
                showAuthMessage(error.message);
            }
        }

        async function handleEmailSignup() {
            hideAuthMessage();
            const email = emailInput.value;
            const password = passwordInput.value;
            if (!email || !password) {
                showAuthMessage("Bitte E-Mail und Passwort eingeben.");
                return;
            }
            try {
                await createUserWithEmailAndPassword(window.firebaseAuth, email, password);
                // onAuthStateChanged will handle screen transition
            } catch (error) {
                showAuthMessage(error.message);
            }
        }

        async function handleGoogleSignIn() {
            hideAuthMessage();
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(window.firebaseAuth, provider);
                // onAuthStateChanged will handle screen transition
            } catch (error) {
                showAuthMessage(error.message);
            }
        }

        async function handleSaveUsername() {
            hideUsernameMessage();
            const displayName = usernameInput.value.trim();
            if (!displayName) {
                showUsernameMessage("Bitte einen gültigen Namen eingeben.");
                return;
            }
            if (!window.currentUserId || !window.firebaseDb) {
                showUsernameMessage("Benutzer nicht angemeldet oder Firebase nicht bereit.");
                return;
            }

            const friendCode = await generateFriendCode();
            if (!friendCode) {
                showUsernameMessage("Fehler beim Generieren des Freundes-Codes.");
                return;
            }

            const profileDocRef = doc(window.firebaseDb, `artifacts/${getAppId()}/users/${window.currentUserId}/profile`, 'userProfile');
            try {
                await setDoc(profileDocRef, { displayName: displayName, friendCode: friendCode }, { merge: true });
                window.userDisplayName = displayName;
                window.userFriendCode = friendCode;
                renderScreen('mainMenu'); // Go to main menu after saving name
            } catch (error) {
                showUsernameMessage("Fehler beim Speichern des Namens: " + error.message);
            }
        }

        async function handleLogout() {
            try {
                await signOut(window.firebaseAuth);
                // onAuthStateChanged will automatically redirect to auth screen
                window.userRankPoints = 0; // Reset rank on logout
                window.userRankName = 'Bronze';
                window.userFriendCode = null; // Clear friend code on logout
                updateStatusDisplay();
            } catch (error) {
                console.error("Error signing out:", error);
            }
        }

        // --- Multiplayer Logic ---
        async function createMultiplayerGame() {
            hideMultiplayerLobbyMessage();
            if (!window.userFriendCode || !window.userDisplayName) {
                showMultiplayerLobbyMessage("Dein Freundes-Code oder Name ist nicht verfügbar. Bitte melde dich erneut an.", true);
                return;
            }

            try {
                const gameRef = doc(window.firebaseDb, `artifacts/${getAppId()}/games`, window.userFriendCode);
                const gameDoc = await getDoc(gameRef);

                if (gameDoc.exists()) {
                    showMultiplayerLobbyMessage("Ein Spiel mit diesem Code existiert bereits. Bitte wähle 'Beitreten' oder starte ein anderes Spiel.", true);
                    return;
                }

                const initialGameState = {
                    players: {
                        X: {
                            uid: window.currentUserId,
                            displayName: window.userDisplayName,
                            friendCode: window.userFriendCode
                        },
                        O: null // Player O is waiting
                    },
                    board: Array(9).fill(null),
                    currentPlayer: 'X',
                    winner: null,
                    winningLine: null,
                    status: 'waiting', // 'waiting', 'playing', 'finished'
                    createdAt: Date.now()
                };

                await setDoc(gameRef, initialGameState);
                currentMultiplayerGameRef = gameRef;
                isPlayerX = true;
                showMultiplayerLobbyMessage(t().gameCreatedSuccess, false);
                subscribeToGameSession(window.userFriendCode);

            } catch (error) {
                console.error("Error creating multiplayer game:", error);
                showMultiplayerLobbyMessage("Fehler beim Erstellen des Spiels: " + error.message, true);
            }
        }

        async function joinMultiplayerGame() {
            hideMultiplayerLobbyMessage();
            const friendCodeToJoin = friendCodeInput.value.trim().toUpperCase();
            if (!friendCodeToJoin) {
                showMultiplayerLobbyMessage("Bitte gib einen Freunde-Code ein.", true);
                return;
            }
            if (!window.userFriendCode || !window.userDisplayName) {
                showMultiplayerLobbyMessage("Dein Freundes-Code oder Name ist nicht verfügbar. Bitte melde dich erneut an.", true);
                return;
            }
            if (friendCodeToJoin === window.userFriendCode) {
                 showMultiplayerLobbyMessage("Du kannst keinem Spiel mit deinem eigenen Freundes-Code beitreten.", true);
                 return;
            }


            try {
                const gameRef = doc(window.firebaseDb, `artifacts/${getAppId()}/games`, friendCodeToJoin);
                const gameDoc = await getDoc(gameRef);

                if (!gameDoc.exists() || gameDoc.data().status === 'finished') {
                    showMultiplayerLobbyMessage(t().gameNotFound, true);
                    return;
                }

                const gameData = gameDoc.data();
                if (gameData.players.O !== null) {
                    showMultiplayerLobbyMessage(t().gameAlreadyStarted, true);
                    return;
                }

                // Update game with Player O's info
                await updateDoc(gameRef, {
                    'players.O': {
                        uid: window.currentUserId,
                        displayName: window.userDisplayName,
                        friendCode: window.userFriendCode
                    },
                    status: 'playing' // Start the game
                });

                currentMultiplayerGameRef = gameRef;
                isPlayerX = false; // Current player is O
                showMultiplayerLobbyMessage(t().gameJoinedSuccess, false);
                subscribeToGameSession(friendCodeToJoin);

            } catch (error) {
                console.error("Error joining multiplayer game:", error);
                showMultiplayerLobbyMessage("Fehler beim Beitreten des Spiels: " + error.message, true);
            }
        }

        function subscribeToGameSession(gameId) {
            if (gameSessionUnsubscribe) { // Unsubscribe from previous game session if any
                gameSessionUnsubscribe();
            }

            currentMultiplayerGameRef = doc(window.firebaseDb, `artifacts/${getAppId()}/games`, gameId);
            gameSessionUnsubscribe = onSnapshot(currentMultiplayerGameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    board = data.board;
                    currentPlayer = data.currentPlayer;
                    winner = data.winner;
                    winningLine = data.winningLine;
                    gameMode = 'playerVsFriend'; // Ensure game mode is correct
                    
                    // Automatically transition to game screen if not already there and game is playing
                    if (data.status === 'playing' && currentScreen !== 'game') {
                        renderScreen('game');
                        resetGameLocalState(); // Reset only local state, not the Firestore game
                    } else if (data.status === 'waiting' && currentScreen !== 'multiplayerLobby') {
                        renderScreen('multiplayerLobby');
                    } else if (data.status === 'finished') {
                        // Game ended, can show a message or transition back
                    }

                    renderBoard();
                    updateStatusDisplay();
                } else {
                    console.log("Multiplayer game ended or not found (document deleted).");
                    resetGame(); // Reset game state
                    backToMainMenu(); // Go back to main menu
                    showMultiplayerLobbyMessage("Das Multiplayer-Spiel wurde beendet.", true);
                }
            }, (error) => {
                console.error("Error listening to game session:", error);
                showMultiplayerLobbyMessage("Verbindungsproblem mit dem Spiel: " + error.message, true);
                resetGame();
                backToMainMenu();
            });
        }

        async function updateGameSession(updates) {
            if (currentMultiplayerGameRef) {
                try {
                    await updateDoc(currentMultiplayerGameRef, updates);
                } catch (error) {
                    console.error("Error updating game session:", error);
                    showMultiplayerLobbyMessage("Fehler beim Aktualisieren des Spiels: " + error.message, true);
                }
            }
        }

        // Resets local game state, not the Firestore document
        const resetGameLocalState = () => {
            board = Array(9).fill(null);
            currentPlayer = 'X';
            winner = null;
            winningLine = null;
            isBotTurn = false;
            if (botThinkingText) botThinkingText.classList.add('hidden');
            if (winRingOverlay) winRingOverlay.classList.add('hidden');
        };

        const resetGame = () => {
            resetGameLocalState(); // Reset local state
            if (gameSessionUnsubscribe) { // Unsubscribe from multiplayer game if active
                gameSessionUnsubscribe();
                gameSessionUnsubscribe = null;
            }
            currentMultiplayerGameRef = null;
            isPlayerX = false;
            renderBoard();
            updateStatusDisplay();
        };

        const backToMainMenu = () => {
            resetGame(); // Reset any active game (local or multiplayer)
            renderScreen('mainMenu');
        };

        // --- Animation Functions ---
        function drawWinningLine() {
            if (!winningLine || !boardContainerDiv || !winningLineOverlay) {
                if (winningLineOverlay) winningLineOverlay.style.opacity = '0';
                return;
            }

            const lineThickness = 8; // in Pixeln
            const boardPaddingPx = 16; // 1rem = 16px (for p-4)

            const boardRect = boardContainerDiv.getBoundingClientRect();
            const effectiveGridWidth = boardRect.width - (2 * boardPaddingPx);
            const effectiveGridHeight = boardRect.height - (2 * boardPaddingPx);

            const cellWidth = effectiveGridWidth / 3;
            const cellHeight = effectiveGridHeight / 3;

            const getSquareCenter = (squareIndex) => {
                const row = Math.floor(squareIndex / 3);
                const col = squareIndex % 3;
                const centerX = boardPaddingPx + col * cellWidth + cellWidth / 2;
                const centerY = boardPaddingPx + row * cellHeight + cellHeight / 2;
                return { x: centerX, y: centerY };
            };

            const startCellIndex = winningLine[0];
            const endCellIndex = winningLine[2]; 

            const startCenter = getSquareCenter(startCellIndex);
            const endCenter = getSquareCenter(endCellIndex);

            const dx = endCenter.x - startCenter.x;
            const dy = endCenter.y - startCenter.y;

            const lineLength = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            const midX = (startCenter.x + endCenter.x) / 2;
            const midY = (startCenter.y + endCenter.y) / 2;

            winningLineOverlay.style.cssText = `
                background-color: rgb(34, 197, 94);
                border-radius: 9999px;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                position: absolute;
                z-index: 10;
                transition: opacity 0.5s ease-out;
                opacity: 1; /* Make visible for animation */
                width: ${lineLength}px;
                height: ${lineThickness}px;
                left: ${midX - lineLength / 2}px;
                top: ${midY - lineThickness / 2}px;
                transform-origin: center center;
                transform: rotate(${angle}deg);
            `;

            // Particle animation
            startParticleAnimation();
        }

        let particlesAnimationFrameId = null;
        let particleArray = [];

        function startParticleAnimation() {
            if (particlesAnimationFrameId) cancelAnimationFrame(particlesAnimationFrameId); // Stop existing animation

            if (!canvas || !ctx || !boardContainerDiv || !winningLine) {
                console.warn("Cannot start particle animation: Missing required elements or winningLine.");
                return;
            }

            const boardRect = boardContainerDiv.getBoundingClientRect();
            canvas.width = boardRect.width;
            canvas.height = boardRect.height;

            particleArray = []; // Clear previous particles
            const boardPaddingPx = 16;
            const effectiveGridWidth = boardRect.width - (2 * boardPaddingPx);
            const effectiveGridHeight = boardRect.height - (2 * boardPaddingPx);
            const cellWidth = effectiveGridWidth / 3;
            const cellHeight = effectiveGridHeight / 3;

            winningLine.forEach(squareIndex => {
                const row = Math.floor(squareIndex / 3);
                const col = squareIndex % 3;
                const centerX = boardPaddingPx + col * cellWidth + cellWidth / 2;
                const centerY = boardPaddingPx + row * cellHeight + cellHeight / 2;

                for (let i = 0; i < 15; i++) {
                    particleArray.push({ // Using particleArray here, consistent with declaration
                        x: centerX,
                        y: centerY,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 0,
                        maxLife: 60 + Math.random() * 30,
                        radius: 2 + Math.random() * 2,
                        color: '0, 255, 0'
                    });
                }
            });

            const animateParticles = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < particleArray.length; i++) { // Using particleArray here
                    const p = particleArray[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life++;

                    const alpha = 1 - (p.life / p.maxLife);
                    const currentRadius = p.radius * Math.max(0.01, alpha);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, currentRadius, 0, Math.PI * 2, false);
                    ctx.fillStyle = `rgba(${p.color}, ${alpha})`;
                    ctx.fill();

                    if (p.life >= p.maxLife) {
                        particleArray.splice(i, 1);
                        i--;
                    }
                }
                if (particleArray.length > 0) { // Check 'particleArray' length
                    animationFrameId = requestAnimationFrame(animateParticles);
                } else {
                    animationFrameId = null; // Animation finished
                }
            };
            animationFrameId = requestAnimationFrame(animateParticles); // Use general animationFrameId
        }

        let winRingAnimationTimeout = null;
        function triggerWinRingAnimation() {
            if (!winRingOverlay) {
                console.warn("winRingOverlay element not found. Cannot trigger win ring animation.");
                return;
            }
            // Clear any existing animation before starting a new one
            if (winRingAnimationTimeout) clearTimeout(winRingAnimationTimeout);
            
            winRingOverlay.classList.remove('hidden');
            // Remove and re-add the class to re-trigger the animation
            winRingOverlay.classList.remove('win-ring');
            void winRingOverlay.offsetWidth; // Trigger reflow to restart animation
            winRingOverlay.classList.add('win-ring');

            winRingAnimationTimeout = setTimeout(() => {
                winRingOverlay.classList.add('hidden');
            }, 1000); // Duration of the animation
        }


        function renderBoard() {
            if (!boardContainerDiv || !canvas || !winningLineOverlay || !winRingOverlay) {
                console.error("Board rendering elements not found."); // Keep this error for critical missing elements
                return;
            }
            boardContainerDiv.innerHTML = ''; // Clear existing board
            // Re-add canvas and winning line overlay as they might be cleared
            boardContainerDiv.appendChild(canvas);
            boardContainerDiv.appendChild(winningLineOverlay);
            boardContainerDiv.appendChild(winRingOverlay); // Ensure win ring overlay is present

            for (let i = 0; i < 9; i++) {
                const squareBtn = document.createElement('button');
                squareBtn.classList.add(
                    'w-24', 'h-24', 'sm:w-28', 'sm:h-28', 'md:w-32', 'md:h-32',
                    'bg-gray-200', 'border-4', 'border-gray-700', 'rounded-md',
                    'flex', 'items-center', 'justify-center', 'text-4xl', 'sm:text-5xl', 'md:text-6xl',
                    'font-bold', 'font-mono', 'text-gray-800', 'shadow-inner',
                    'hover:bg-gray-300', 'transition-colors', 'duration-200',
                    'relative', 'z-20' // Higher z-index to be clickable over canvas
                );
                squareBtn.dataset.index = i; // Store index for click handler
                squareBtn.textContent = board[i];

                // Disable logic based on current game state and game mode
                let disableButton = false;
                if (winner || board[i] !== null) {
                    disableButton = true;
                } else if (gameMode === 'playerVsBot' && isBotTurn) {
                    disableButton = true;
                } else if (gameMode === 'playerVsFriend') {
                    // In multiplayer, disable if it's not our turn
                    if ((isPlayerX && currentPlayer === 'O') || (!isPlayerX && currentPlayer === 'X')) {
                        disableButton = true;
                    }
                }

                if (disableButton) {
                    squareBtn.disabled = true;
                    squareBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    squareBtn.disabled = false;
                    squareBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                
                squareBtn.addEventListener('click', () => handleSquareClick(i));
                boardContainerDiv.appendChild(squareBtn);
            }

            if (winningLine) {
                drawWinningLine();
            } else {
                winningLineOverlay.style.opacity = '0';
            }
        }


        // Initial render logic
        document.addEventListener('DOMContentLoaded', () => {
            // Assign ALL DOM elements once the document is ready, at the very beginning
            mainMenuDiv = document.getElementById('main-menu');
            gameAreaDiv = document.getElementById('game-area');
            boardContainerDiv = document.getElementById('game-board-container');
            playerVsPlayerBtn = document.getElementById('player-vs-player-btn');
            playerVsBotBtn = document.getElementById('player-vs-bot-btn');
            playerVsFriendBtn = document.getElementById('player-vs-friend-btn'); // New
            newGameBtn = document.getElementById('new-game-btn');
            backToMenuBtn = document.getElementById('back-to-menu-btn');
            currentPlayerText = document.getElementById('current-player-text');
            botThinkingText = document.getElementById('bot-thinking-text');
            languageToggleBtn = document.getElementById('language-toggle');
            currentLanguageDisplay = document.getElementById('current-language-display');
            gameTitleDisplay = document.getElementById('game-title');
            rankInfoDisplay = document.getElementById('rank-info');
            userIdDisplay = document.getElementById('user-id-display');
            winningLineOverlay = document.getElementById('winning-line-overlay');
            winRingOverlay = document.getElementById('win-ring-overlay');
            rankProgressOverlay = document.getElementById('rank-progress-overlay');
            rankOverlayTitle = document.getElementById('rank-overlay-title');
            prevRankText = document.getElementById('prev-rank-text');
            newRankText = document.getElementById('new-rank-name'); 
            animatedPointsDisplay = document.getElementById('animated-points');

            // New Auth/Username elements
            authScreenDiv = document.getElementById('auth-screen');
            emailInput = document.getElementById('email-input');
            passwordInput = document.getElementById('password-input');
            loginBtn = document.getElementById('login-btn');
            signupBtn = document.getElementById('signup-btn');
            googleSignInBtn = document.getElementById('google-sign-in-btn');
            authMessageDisplay = document.getElementById('auth-message');
            authOrText = document.getElementById('auth-or-text'); // New
            usernameScreenDiv = document.getElementById('username-screen');
            usernameInput = document.getElementById('username-input');
            saveUsernameBtn = document.getElementById('save-username-btn');
            usernameMessageDisplay = document.getElementById('username-message');
            authTitleDisplay = document.getElementById('auth-title');
            usernameTitleDisplay = document.getElementById('username-title');
            usernamePromptDisplay = document.querySelector('#username-screen p'); // Select the p tag in username screen
            logoutBtn = document.getElementById('logout-btn');

            // Profile Display elements
            profileDisplay = document.getElementById('profile-display');
            usernameInProfile = document.getElementById('username-in-profile');
            rankNameInProfile = document.getElementById('rank-name-in-profile');
            rankProgressBarFill = document.getElementById('rank-progress-bar-fill');
            rankPointsInProfile = document.getElementById('rank-points-in-profile');

            // Multiplayer Lobby elements
            multiplayerLobbyScreen = document.getElementById('multiplayer-lobby-screen');
            multiplayerLobbyTitle = document.getElementById('multiplayer-lobby-title');
            yourCodeText = document.getElementById('your-code-text');
            yourFriendCodeDisplay = document.getElementById('your-friend-code');
            friendCodeInput = document.getElementById('friend-code-input');
            joinFriendGameBtn = document.getElementById('join-friend-game-btn');
            orCreateGameText = document.getElementById('or-create-game-text');
            createMultiplayerGameBtn = document.getElementById('create-multiplayer-game-btn');
            multiplayerLobbyMessage = document.getElementById('multiplayer-lobby-message');
            backFromLobbyBtn = document.getElementById('back-from-lobby-btn');


            canvas = document.getElementById('particles-canvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
            }
            
            // --- Event Listeners ---
            if (playerVsPlayerBtn) {
                playerVsPlayerBtn.addEventListener('click', () => {
                    gameMode = 'playerVsPlayer';
                    renderScreen('game'); // Directly go to game screen
                    resetGame();
                });
            }

            if (playerVsBotBtn) {
                playerVsBotBtn.addEventListener('click', () => {
                    gameMode = 'playerVsBot';
                    renderScreen('game'); // Directly go to game screen
                    resetGame();
                });
            }

            if (playerVsFriendBtn) { // New event listener for Player vs Friend
                playerVsFriendBtn.addEventListener('click', () => {
                    gameMode = 'playerVsFriend'; // Set game mode
                    renderScreen('multiplayerLobby'); // Go to multiplayer lobby
                    hideMultiplayerLobbyMessage();
                });
            }

            if (newGameBtn) newGameBtn.addEventListener('click', resetGame);
            if (backToMenuBtn) backToMenuBtn.addEventListener('click', backToMainMenu);
            if (languageToggleBtn) {
                languageToggleBtn.addEventListener('click', () => {
                    language = (language === 'de' ? 'en' : 'de');
                    updateTextContent();
                });
            }

            // Auth Screen Event Listeners
            if (loginBtn) loginBtn.addEventListener('click', handleEmailLogin);
            if (signupBtn) signupBtn.addEventListener('click', handleEmailSignup);
            if (googleSignInBtn) googleSignInBtn.addEventListener('click', handleGoogleSignIn);

            // Username Screen Event Listener
            if (saveUsernameBtn) saveUsernameBtn.addEventListener('click', handleSaveUsername);

            // Logout Button Event Listener
            if (logoutBtn) logoutBtn.addEventListener('click', handleLogout);

            // Multiplayer Lobby Event Listeners
            if (createMultiplayerGameBtn) createMultiplayerGameBtn.addEventListener('click', createMultiplayerGame);
            if (joinFriendGameBtn) joinFriendGameBtn.addEventListener('click', joinMultiplayerGame);
            if (backFromLobbyBtn) backFromLobbyBtn.addEventListener('click', backToMainMenu);

            // --- End of Event Listeners ---

            // Call functions that rely on elements *after* they have all been assigned
            updateTextContent(); 
            renderBoard(); // Render board initially (even if hidden) to ensure elements exist
            window.initializeFirebase(); // Initialize Firebase once DOM is ready
        });
    </script>
</body>
</html>
